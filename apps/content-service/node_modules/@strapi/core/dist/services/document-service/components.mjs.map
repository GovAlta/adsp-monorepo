{"version":3,"file":"components.mjs","sources":["../../../src/services/document-service/components.ts"],"sourcesContent":["import _ from 'lodash';\nimport { has, omit, pipe, assign, curry } from 'lodash/fp';\nimport type { Utils, UID, Schema, Data, Modules } from '@strapi/types';\nimport { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';\nimport {\n  getComponentJoinTableName,\n  getComponentJoinColumnEntityName,\n  getComponentJoinColumnInverseName,\n  getComponentTypeColumn,\n} from '../../utils/transform-content-types-to-models';\n\n// type aliases for readability\ntype Input<T extends UID.Schema> = Modules.Documents.Params.Data.Input<T>;\n\ntype LoadedComponents<TUID extends UID.Schema> = Data.Entity<\n  TUID,\n  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>\n>;\n\ntype SingleComponentValue = Schema.Attribute.ComponentValue<UID.Component, false>;\ntype RepeatableComponentValue = Schema.Attribute.ComponentValue<UID.Component, true>;\n\ntype ComponentValue = SingleComponentValue | RepeatableComponentValue;\n\ntype DynamicZoneValue = Schema.Attribute.DynamicZoneValue<UID.Component[]>;\n\ntype ComponentBody = {\n  [key: string]: ComponentValue | DynamicZoneValue;\n};\n\nconst omitComponentData = curry(\n  (schema: Schema.Schema, data: Input<UID.Schema>): Partial<Input<UID.Schema>> => {\n    const { attributes } = schema;\n    const componentAttributes = Object.keys(attributes).filter((attributeName) =>\n      contentTypesUtils.isComponentAttribute(attributes[attributeName])\n    );\n\n    return omit(componentAttributes, data);\n  }\n);\n\n// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer\nconst createComponents = async <TUID extends UID.Schema, TData extends Input<TUID>>(\n  uid: TUID,\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[attributeName as keyof TData];\n\n      if (componentValue === null) {\n        continue;\n      }\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>\n          createComponent(componentUID, value)\n        );\n\n        componentBody[attributeName] = components.map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await createComponent(\n          componentUID,\n          componentValue as Input<UID.Component>\n        );\n\n        componentBody[attributeName] = {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n\n      continue;\n    }\n\n    if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[\n        attributeName as keyof TData\n      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      const createDynamicZoneComponents = async (\n        value: Utils.Array.Values<typeof dynamiczoneValues>\n      ) => {\n        const { id } = await createComponent(value.__component, value);\n        return {\n          id,\n          __component: value.__component,\n          __pivot: {\n            field: attributeName,\n          },\n        };\n      };\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(\n        dynamiczoneValues,\n        createDynamicZoneComponents\n      );\n\n      continue;\n    }\n  }\n\n  return componentBody;\n};\n\nconst getComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entity: { id: Modules.EntityService.Params.Attribute.ID }\n): Promise<LoadedComponents<TUID>> => {\n  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));\n\n  if (_.isEmpty(componentAttributes)) {\n    return {} as LoadedComponents<TUID>;\n  }\n\n  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;\n};\n\n/*\n  delete old components\n  create or update\n*/\nconst updateComponents = async <TUID extends UID.Schema, TData extends Partial<Input<TUID>>>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: TData\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const componentBody: ComponentBody = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (!has(attributeName, data)) {\n      continue;\n    }\n\n    if (attribute.type === 'component') {\n      const { component: componentUID, repeatable = false } = attribute;\n\n      const componentValue = data[attributeName as keyof TData] as ComponentValue;\n      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);\n\n      if (repeatable === true) {\n        if (!Array.isArray(componentValue)) {\n          throw new Error('Expected an array to create repeatable component');\n        }\n\n        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>\n          updateOrCreateComponent(componentUID, value)\n        );\n\n        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {\n          return {\n            id,\n            __pivot: {\n              field: attributeName,\n              component_type: componentUID,\n            },\n          };\n        });\n      } else {\n        const component = await updateOrCreateComponent(componentUID, componentValue);\n        componentBody[attributeName] = component && {\n          id: component.id,\n          __pivot: {\n            field: attributeName,\n            component_type: componentUID,\n          },\n        };\n      }\n    } else if (attribute.type === 'dynamiczone') {\n      const dynamiczoneValues = data[attributeName as keyof TData] as DynamicZoneValue;\n\n      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);\n\n      if (!Array.isArray(dynamiczoneValues)) {\n        throw new Error('Expected an array to create repeatable component');\n      }\n\n      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1\n      componentBody[attributeName] = await async.map(dynamiczoneValues, async (value: any) => {\n        const { id } = await updateOrCreateComponent(value.__component, value);\n\n        return {\n          id,\n          __component: value.__component,\n          __pivot: {\n            field: attributeName,\n          },\n        };\n      });\n    }\n  }\n\n  return componentBody;\n};\n\nconst pickStringifiedId = ({\n  id,\n}: {\n  id: Modules.EntityService.Params.Attribute.ID;\n}): Modules.EntityService.Params.Attribute.ID & string => {\n  if (typeof id === 'string') {\n    return id;\n  }\n\n  return `${id}`;\n};\n\nconst deleteOldComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  componentUID: UID.Component,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  componentValue: ComponentValue\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as ComponentValue;\n  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);\n  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);\n\n  idsToKeep.forEach((id) => {\n    if (!allIds.includes(id)) {\n      throw new errors.ApplicationError(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n    }\n  });\n\n  const idsToDelete = _.difference(allIds, idsToKeep);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      await deleteComponent(componentUID, { id: idToDelete });\n    }\n  }\n};\n\nconst deleteOldDZComponents = async <TUID extends UID.Schema>(\n  uid: TUID,\n  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  attributeName: string,\n  dynamiczoneValues: DynamicZoneValue\n) => {\n  const previousValue = (await strapi.db\n    .query(uid)\n    .load(entityToUpdate, attributeName)) as DynamicZoneValue;\n\n  const idsToKeep = _.castArray(dynamiczoneValues)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  const allIds = _.castArray(previousValue)\n    .filter(has('id'))\n    .map((v) => ({\n      id: pickStringifiedId(v),\n      __component: v.__component,\n    }));\n\n  idsToKeep.forEach(({ id, __component }) => {\n    if (!allIds.find((el) => el.id === id && el.__component === __component)) {\n      const err = new Error(\n        `Some of the provided components in ${attributeName} are not related to the entity`\n      );\n\n      Object.assign(err, { status: 400 });\n      throw err;\n    }\n  });\n\n  type IdsToDelete = DynamicZoneValue;\n\n  const idsToDelete = allIds.reduce((acc, { id, __component }) => {\n    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {\n      acc.push({ id, __component });\n    }\n\n    return acc;\n  }, [] as IdsToDelete);\n\n  if (idsToDelete.length > 0) {\n    for (const idToDelete of idsToDelete) {\n      const { id, __component } = idToDelete;\n      await deleteComponent(__component, { id });\n    }\n  }\n};\n\nconst deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(\n  uid: TUID,\n  entityToDelete: TEntity,\n  { loadComponents = true } = {}\n) => {\n  const { attributes = {} } = strapi.getModel(uid);\n\n  const attributeNames = Object.keys(attributes);\n\n  for (const attributeName of attributeNames) {\n    const attribute = attributes[attributeName];\n\n    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {\n      let value;\n\n      if (loadComponents) {\n        value = await strapi.db.query(uid).load(entityToDelete, attributeName);\n      } else {\n        value = entityToDelete[attributeName as keyof TEntity];\n      }\n\n      if (!value) {\n        continue;\n      }\n\n      if (attribute.type === 'component') {\n        const { component: componentUID } = attribute;\n        await async.map(_.castArray(value), (subValue: any) =>\n          deleteComponent(componentUID, subValue)\n        );\n      } else {\n        await async.map(_.castArray(value), (subValue: any) =>\n          deleteComponent(subValue.__component, subValue)\n        );\n      }\n\n      continue;\n    }\n  }\n};\n\n/** *************************\n    Component queries\n************************** */\n\n// components can have nested compos so this must be recursive\nconst createComponent = async <TUID extends UID.Component>(uid: TUID, data: Input<TUID>) => {\n  const schema = strapi.getModel(uid);\n\n  const componentData = await createComponents(uid, data);\n\n  const transform = pipe(\n    // Make sure we don't save the component with a pre-defined ID\n    omit('id'),\n    assignComponentData(schema, componentData)\n  );\n\n  return strapi.db.query(uid).create({ data: transform(data) });\n};\n\n// components can have nested compos so this must be recursive\nconst updateComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },\n  data: Input<TUID>\n) => {\n  const schema = strapi.getModel(uid);\n\n  const componentData = await updateComponents(uid, componentToUpdate, data);\n\n  return strapi.db.query(uid).update({\n    where: {\n      id: componentToUpdate.id,\n    },\n    data: assignComponentData(schema, componentData, data),\n  });\n};\n\nconst updateOrCreateComponent = <TUID extends UID.Component>(\n  componentUID: TUID,\n  value: Input<TUID>\n) => {\n  if (value === null) {\n    return null;\n  }\n\n  // update\n  if ('id' in value && typeof value.id !== 'undefined') {\n    // TODO: verify the compo is associated with the entity\n    return updateComponent(componentUID, { id: value.id }, value);\n  }\n\n  // create\n  return createComponent(componentUID, value);\n};\n\nconst deleteComponent = async <TUID extends UID.Component>(\n  uid: TUID,\n  componentToDelete: Data.Component<TUID>\n) => {\n  await deleteComponents(uid, componentToDelete);\n  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });\n};\n\nconst assignComponentData = curry(\n  (schema: Schema.Schema, componentData: ComponentBody, data: Input<UID.Schema>) => {\n    return pipe(omitComponentData(schema), assign(componentData))(data);\n  }\n);\n\n/** *************************\n    Component relation handling for document operations\n************************** */\n\n/**\n * Find the parent entry of a component instance.\n *\n * Given a component model, a specific component instance id, and the list of\n * possible parent content types (those that can embed this component),\n * this function checks each parent's *_cmps join table to see if the component\n * instance is linked to a parent entity.\n *\n * - Returns the parent uid, parent table name, and parent id if found.\n * - Returns null if no parent relationship exists.\n */\nconst findComponentParent = async (\n  componentSchema: Schema.Component,\n  componentId: number | string,\n  parentSchemasForComponent: (Schema.ContentType | Schema.Component)[],\n  opts?: { trx?: any }\n): Promise<{ uid: string; table: string; parentId: number | string } | null> => {\n  if (!componentSchema?.uid) return null;\n\n  const schemaBuilder = strapi.db.getSchemaConnection(opts?.trx);\n  const withTrx = (qb: any) => (opts?.trx ? qb.transacting(opts.trx) : qb);\n\n  for (const parent of parentSchemasForComponent) {\n    if (!parent.collectionName) continue;\n\n    // Use the exact same functions that create the tables\n    const identifiers = strapi.db.metadata.identifiers;\n    const joinTableName = getComponentJoinTableName(parent.collectionName, identifiers);\n\n    try {\n      const tableExists = await schemaBuilder.hasTable(joinTableName);\n      if (!tableExists) continue;\n\n      // Use the exact same functions that create the columns\n      const entityIdColumn = getComponentJoinColumnEntityName(identifiers);\n      const componentIdColumn = getComponentJoinColumnInverseName(identifiers);\n      const componentTypeColumn = getComponentTypeColumn(identifiers);\n\n      const parentRow = await withTrx(strapi.db.getConnection(joinTableName))\n        .where({\n          [componentIdColumn]: componentId,\n          [componentTypeColumn]: componentSchema.uid,\n        })\n        .first(entityIdColumn);\n\n      if (parentRow) {\n        return {\n          uid: parent.uid,\n          table: parent.collectionName,\n          parentId: parentRow[entityIdColumn],\n        };\n      }\n    } catch {\n      continue;\n    }\n  }\n\n  return null;\n};\n\n/**\n * Finds content types that contain the given component and have draft & publish enabled.\n */\nconst getParentSchemasForComponent = (\n  componentSchema: Schema.Component\n): Array<Schema.ContentType | Schema.Component> => {\n  // Find direct parents in contentTypes and components\n  return [...Object.values(strapi.contentTypes), ...Object.values(strapi.components)].filter(\n    (schema: any) => {\n      if (!schema?.attributes) return false;\n      return Object.values(schema.attributes).some((attr: any) => {\n        return (\n          (attr.type === 'component' && attr.component === componentSchema.uid) ||\n          (attr.type === 'dynamiczone' && attr.components?.includes(componentSchema.uid))\n        );\n      });\n    }\n  );\n};\n\n/**\n * Determines if a component relation should be propagated to a new document version\n * when a document with draft and publish is updated.\n */\nconst shouldPropagateComponentRelationToNewVersion = async (\n  componentRelation: Record<string, any>,\n  componentSchema: Schema.Component,\n  parentSchemasForComponent: (Schema.ContentType | Schema.Component)[],\n  trx: any\n): Promise<boolean> => {\n  // Get the component ID column name using the actual component model name\n  const componentIdColumn = strapi.db.metadata.identifiers.getJoinColumnAttributeIdName(\n    _.snakeCase(componentSchema.modelName)\n  );\n\n  const componentId = componentRelation[componentIdColumn] ?? componentRelation.parentId;\n\n  const parent = await findComponentParent(\n    componentSchema,\n    componentId,\n    parentSchemasForComponent,\n    { trx }\n  );\n\n  // Keep relation if component has no parent entry\n  if (!parent?.uid) {\n    return true;\n  }\n\n  if (strapi.components[parent.uid as UID.Component]) {\n    // If the parent is a component, we need to check its parents recursively\n    const parentComponentSchema = strapi.components[parent.uid as UID.Component];\n    const grandParentSchemas = getParentSchemasForComponent(parentComponentSchema);\n    return shouldPropagateComponentRelationToNewVersion(\n      parent,\n      parentComponentSchema,\n      grandParentSchemas,\n      trx\n    );\n  }\n\n  const parentContentType = strapi.contentTypes[parent.uid as UID.ContentType];\n\n  // Keep relation if parent doesn't have draft & publish enabled\n  if (!parentContentType?.options?.draftAndPublish) {\n    return true;\n  }\n\n  // Discard relation if parent has draft & publish enabled\n  return false;\n};\n\n/**\n * Creates a filter function for component relations that can be passed to the generic\n * unidirectional relations utility\n */\nconst createComponentRelationFilter = () => {\n  return async (\n    relation: Record<string, any>,\n    model: Schema.Component | Schema.ContentType,\n    trx: any\n  ): Promise<boolean> => {\n    // Only apply component-specific filtering for components\n    if (model.modelType !== 'component') {\n      return true;\n    }\n\n    const componentSchema = model as Schema.Component;\n    const parentSchemas = getParentSchemasForComponent(componentSchema);\n\n    // Exit if no draft & publish parent types exist\n    if (parentSchemas.length === 0) {\n      return true;\n    }\n\n    return shouldPropagateComponentRelationToNewVersion(\n      relation,\n      componentSchema,\n      parentSchemas,\n      trx\n    );\n  };\n};\n\nexport {\n  omitComponentData,\n  assignComponentData,\n  getComponents,\n  createComponents,\n  updateComponents,\n  deleteComponents,\n  deleteComponent,\n  createComponentRelationFilter,\n  findComponentParent,\n  getParentSchemasForComponent,\n};\n"],"names":["omitComponentData","curry","schema","data","attributes","componentAttributes","Object","keys","filter","attributeName","contentTypesUtils","isComponentAttribute","omit","createComponents","uid","strapi","getModel","componentBody","attributeNames","attribute","has","type","component","componentUID","repeatable","componentValue","Array","isArray","Error","components","async","map","value","createComponent","id","__pivot","field","component_type","dynamiczoneValues","createDynamicZoneComponents","__component","getComponents","entity","getComponentAttributes","_","isEmpty","db","query","load","updateComponents","entityToUpdate","deleteOldComponents","updateOrCreateComponent","negate","isNil","deleteOldDZComponents","pickStringifiedId","previousValue","idsToKeep","castArray","allIds","forEach","includes","errors","ApplicationError","idsToDelete","difference","length","idToDelete","deleteComponent","v","find","el","err","assign","status","reduce","acc","push","deleteComponents","entityToDelete","loadComponents","subValue","componentData","transform","pipe","assignComponentData","create","updateComponent","componentToUpdate","update","where","componentToDelete","delete","findComponentParent","componentSchema","componentId","parentSchemasForComponent","opts","schemaBuilder","getSchemaConnection","trx","withTrx","qb","transacting","parent","collectionName","identifiers","metadata","joinTableName","getComponentJoinTableName","tableExists","hasTable","entityIdColumn","getComponentJoinColumnEntityName","componentIdColumn","getComponentJoinColumnInverseName","componentTypeColumn","getComponentTypeColumn","parentRow","getConnection","first","table","parentId","getParentSchemasForComponent","values","contentTypes","some","attr","shouldPropagateComponentRelationToNewVersion","componentRelation","getJoinColumnAttributeIdName","snakeCase","modelName","parentComponentSchema","grandParentSchemas","parentContentType","options","draftAndPublish","createComponentRelationFilter","relation","model","modelType","parentSchemas"],"mappings":"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"}