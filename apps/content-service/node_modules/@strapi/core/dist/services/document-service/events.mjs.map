{"version":3,"file":"events.mjs","sources":["../../../src/services/document-service/events.ts"],"sourcesContent":["import type { UID, Utils, Modules, Core } from '@strapi/types';\nimport { sanitize } from '@strapi/utils';\n\nimport { getDeepPopulate } from './utils/populate';\n\nconst EVENTS = {\n  ENTRY_CREATE: 'entry.create',\n  ENTRY_UPDATE: 'entry.update',\n  ENTRY_DELETE: 'entry.delete',\n  ENTRY_PUBLISH: 'entry.publish',\n  ENTRY_UNPUBLISH: 'entry.unpublish',\n  ENTRY_DRAFT_DISCARD: 'entry.draft-discard',\n};\n\ntype EventName = Utils.Object.Values<typeof EVENTS>;\n\n/**\n * Manager to trigger entry related events\n *\n * It will populate the entry if it is not a delete event.\n * So the event payload will contain the full entry.\n */\nconst createEventManager = (strapi: Core.Strapi, uid: UID.Schema) => {\n  const populate = getDeepPopulate(uid, {});\n  const model = strapi.getModel(uid);\n\n  const emitEvent = async (eventName: EventName, entry: Modules.Documents.AnyDocument) => {\n    // There is no need to populate the entry if it has been deleted\n    let populatedEntry = entry;\n    if (![EVENTS.ENTRY_DELETE, EVENTS.ENTRY_UNPUBLISH].includes(eventName)) {\n      populatedEntry = await strapi.db.query(uid).findOne({ where: { id: entry.id }, populate });\n    }\n\n    const sanitizedEntry = await sanitize.sanitizers.defaultSanitizeOutput(\n      {\n        schema: model,\n        getModel: (uid) => strapi.getModel(uid as UID.Schema),\n      },\n      populatedEntry\n    );\n\n    await strapi.eventHub.emit(eventName, {\n      model: model.modelName,\n      uid: model.uid,\n      entry: sanitizedEntry,\n    });\n  };\n\n  return {\n    /**\n     * strapi.db.query might reuse the transaction used in the doc service request,\n     * so this is executed after that transaction is committed.\n     */\n    emitEvent(eventName: EventName, entry: Modules.Documents.AnyDocument) {\n      strapi.db.transaction(({ onCommit }) => {\n        onCommit(() => emitEvent(eventName, entry));\n      });\n    },\n  };\n};\n\nexport { createEventManager };\n"],"names":["EVENTS","ENTRY_CREATE","ENTRY_UPDATE","ENTRY_DELETE","ENTRY_PUBLISH","ENTRY_UNPUBLISH","ENTRY_DRAFT_DISCARD","createEventManager","strapi","uid","populate","getDeepPopulate","model","getModel","emitEvent","eventName","entry","populatedEntry","includes","db","query","findOne","where","id","sanitizedEntry","sanitize","sanitizers","defaultSanitizeOutput","schema","eventHub","emit","modelName","transaction","onCommit"],"mappings":";;;AAKA,MAAMA,MAAS,GAAA;IACbC,YAAc,EAAA,cAAA;IACdC,YAAc,EAAA,cAAA;IACdC,YAAc,EAAA,cAAA;IACdC,aAAe,EAAA,eAAA;IACfC,eAAiB,EAAA,iBAAA;IACjBC,mBAAqB,EAAA;AACvB,CAAA;AAIA;;;;;IAMA,MAAMC,kBAAqB,GAAA,CAACC,MAAqBC,EAAAA,GAAAA,GAAAA;IAC/C,MAAMC,QAAAA,GAAWC,eAAgBF,CAAAA,GAAAA,EAAK,EAAC,CAAA;IACvC,MAAMG,KAAAA,GAAQJ,MAAOK,CAAAA,QAAQ,CAACJ,GAAAA,CAAAA;IAE9B,MAAMK,SAAAA,GAAY,OAAOC,SAAsBC,EAAAA,KAAAA,GAAAA;;AAE7C,QAAA,IAAIC,cAAiBD,GAAAA,KAAAA;AACrB,QAAA,IAAI,CAAC;AAAChB,YAAAA,MAAAA,CAAOG,YAAY;AAAEH,YAAAA,MAAAA,CAAOK;SAAgB,CAACa,QAAQ,CAACH,SAAY,CAAA,EAAA;YACtEE,cAAiB,GAAA,MAAMT,OAAOW,EAAE,CAACC,KAAK,CAACX,GAAAA,CAAAA,CAAKY,OAAO,CAAC;gBAAEC,KAAO,EAAA;AAAEC,oBAAAA,EAAAA,EAAIP,MAAMO;AAAG,iBAAA;AAAGb,gBAAAA;AAAS,aAAA,CAAA;AAC1F;AAEA,QAAA,MAAMc,iBAAiB,MAAMC,QAAAA,CAASC,UAAU,CAACC,qBAAqB,CACpE;YACEC,MAAQhB,EAAAA,KAAAA;AACRC,YAAAA,QAAAA,EAAU,CAACJ,GAAAA,GAAQD,MAAOK,CAAAA,QAAQ,CAACJ,GAAAA;SAErCQ,EAAAA,cAAAA,CAAAA;AAGF,QAAA,MAAMT,MAAOqB,CAAAA,QAAQ,CAACC,IAAI,CAACf,SAAW,EAAA;AACpCH,YAAAA,KAAAA,EAAOA,MAAMmB,SAAS;AACtBtB,YAAAA,GAAAA,EAAKG,MAAMH,GAAG;YACdO,KAAOQ,EAAAA;AACT,SAAA,CAAA;AACF,KAAA;IAEA,OAAO;AACL;;;QAIAV,SAAAA,CAAAA,CAAUC,SAAoB,EAAEC,KAAoC,EAAA;AAClER,YAAAA,MAAAA,CAAOW,EAAE,CAACa,WAAW,CAAC,CAAC,EAAEC,QAAQ,EAAE,GAAA;gBACjCA,QAAS,CAAA,IAAMnB,UAAUC,SAAWC,EAAAA,KAAAA,CAAAA,CAAAA;AACtC,aAAA,CAAA;AACF;AACF,KAAA;AACF;;;;"}