{"version":3,"file":"data-ids.mjs","sources":["../../../../../../src/services/document-service/transform/relations/transform/data-ids.ts"],"sourcesContent":["import { curry } from 'lodash/fp';\n\nimport type { UID } from '@strapi/types';\nimport { errors, relations } from '@strapi/utils';\n\nimport { ID, LongHandDocument } from '../utils/types';\nimport { IdMap } from '../../id-map';\nimport { getRelationTargetLocale } from '../utils/i18n';\nimport { getRelationTargetStatus } from '../utils/dp';\nimport { mapRelation, traverseEntityRelations } from '../utils/map-relation';\n\nconst { isPolymorphic } = relations;\n\ninterface Options {\n  uid: UID.Schema;\n  locale?: string | null;\n  status?: 'draft' | 'published';\n  allowMissingId?: boolean; // Whether to ignore missing ids and not throw any error\n}\n\n/**\n * Get the entry ids for a given documentId.\n */\nconst getRelationIds = curry(\n  (idMap: IdMap, source: Options, targetUid: UID.Schema, relation: LongHandDocument) => {\n    // locale to connect to\n    const targetLocale = getRelationTargetLocale(relation, {\n      targetUid,\n      sourceUid: source.uid,\n      sourceLocale: source.locale,\n    });\n\n    // status(es) to connect to\n    const targetStatus = getRelationTargetStatus(relation, {\n      targetUid,\n      sourceUid: source.uid,\n      sourceStatus: source.status,\n    });\n\n    const ids: ID[] = [];\n\n    // Find mapping between documentID -> id(s).\n    // There are scenarios where a single documentID can map to multiple ids.\n    // e.g when connecting Non DP -> DP and connecting to both the draft and publish version at the same time\n    for (const tStatus of targetStatus) {\n      const entryId = idMap.get({\n        uid: targetUid,\n        documentId: relation.documentId,\n        locale: targetLocale,\n        status: tStatus,\n      });\n\n      if (entryId) ids.push(entryId);\n    }\n\n    if (!ids.length && !source.allowMissingId) {\n      throw new errors.ValidationError(\n        `Document with id \"${relation.documentId}\", locale \"${targetLocale}\" not found`\n      );\n    }\n\n    return ids;\n  }\n);\n\n/**\n * Iterate over all relations of a data object and transform all relational document ids to entity ids.\n */\nconst transformDataIdsVisitor = (idMap: IdMap, data: Record<string, any>, source: Options) => {\n  return traverseEntityRelations(\n    async ({ key, value, attribute }, { set }) => {\n      if (!attribute) {\n        return;\n      }\n      const isPolymorphicRelation = isPolymorphic(attribute);\n      const getIds = getRelationIds(idMap, source);\n\n      // Transform the relation documentId to entity id\n      const newRelation = await mapRelation((relation) => {\n        if (!relation || !relation.documentId) {\n          return relation;\n        }\n\n        // Find relational attributes, and return the document ids\n        // if its a polymorphic relation we need to get it from the data itself\n        const targetUid: UID.Schema = isPolymorphicRelation ? relation.__type : attribute.target;\n        const ids: ID[] = getIds(targetUid, relation);\n\n        // Handle positional arguments\n        const position = { ...relation.position };\n\n        // The positional relation target uid can be different for polymorphic relations\n        let positionTargetUid: UID.Schema = targetUid;\n        if (isPolymorphicRelation && position?.__type) {\n          positionTargetUid = position.__type;\n        }\n\n        if (position.before) {\n          const beforeRelation = { ...relation, ...position, documentId: position.before };\n          const beforeIds: ID[] = getIds(positionTargetUid, beforeRelation);\n          position.before = beforeIds.at(0);\n        }\n\n        if (position.after) {\n          const afterRelation = { ...relation, ...position, documentId: position.after };\n          position.after = getIds(positionTargetUid, afterRelation).at(0);\n        }\n\n        // Transform all ids to new relations\n        return ids?.map((id) => {\n          const newRelation = { id } as typeof relation;\n\n          if (relation.position) {\n            newRelation.position = position;\n          }\n\n          // Insert type if its a polymorphic relation\n          if (isPolymorphicRelation) {\n            newRelation.__type = targetUid;\n          }\n\n          return newRelation;\n        });\n      }, value as any);\n\n      set(key, newRelation as any);\n    },\n    { schema: strapi.getModel(source.uid), getModel: strapi.getModel.bind(strapi) },\n    data\n  );\n};\n\nexport { transformDataIdsVisitor };\n"],"names":["isPolymorphic","relations","getRelationIds","curry","idMap","source","targetUid","relation","targetLocale","getRelationTargetLocale","sourceUid","uid","sourceLocale","locale","targetStatus","getRelationTargetStatus","sourceStatus","status","ids","tStatus","entryId","get","documentId","push","length","allowMissingId","errors","ValidationError","transformDataIdsVisitor","data","traverseEntityRelations","key","value","attribute","set","isPolymorphicRelation","getIds","newRelation","mapRelation","__type","target","position","positionTargetUid","before","beforeRelation","beforeIds","at","after","afterRelation","map","id","schema","strapi","getModel","bind"],"mappings":"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"}