{"version":3,"file":"transform-content-types-to-models.js","sources":["../../src/utils/transform-content-types-to-models.ts"],"sourcesContent":["import { type Model, type Identifiers } from '@strapi/database';\nimport type { Struct, Schema } from '@strapi/types';\nimport { createId } from '@paralleldrive/cuid2';\nimport assert from 'node:assert';\nimport _ from 'lodash/fp';\n\n/**\n * Because strapi/database models don't know about things like components or dynamic zones, we use this file to convert them\n * to a relations format that it recognizes\n *\n * Therefore we have to keep an additional set of helpers/extensions to the database naming methods\n *\n * IMPORTANT!\n * If we use short versions of anything, we MUST call getNameFromTokens directly; attempting to shorten them ourselves\n * prevents the unshortened name map from being filled properly, so for example it will think that the short name\n * 'collection4f3a_cmps' maps to the unshortened 'collectionname_cmps' rather than 'collectionname_components'\n * Therefore, we only use the identifiers helpers in cases where we do not do any of our own shortening\n */\n\nexport const getComponentJoinTableName = (collectionName: string, identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: collectionName, compressible: true },\n    { name: 'components', shortName: 'cmps', compressible: false },\n  ]);\n};\n\nexport const getDzJoinTableName = (collectionName: string, identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: collectionName, compressible: true },\n    { name: 'components', shortName: 'cmps', compressible: false },\n  ]);\n};\n\nexport const getComponentJoinColumnEntityName = (identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: 'entity', compressible: false },\n    { name: 'id', compressible: false },\n  ]);\n};\n\nexport const getComponentJoinColumnInverseName = (identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: 'component', shortName: 'cmp', compressible: false },\n    { name: 'id', compressible: false },\n  ]);\n};\n\nexport const getComponentTypeColumn = (identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([{ name: 'component_type', compressible: false }]);\n};\n\nexport const getComponentFkIndexName = (contentType: string, identifiers: Identifiers) => {\n  return identifiers.getNameFromTokens([\n    { name: contentType, compressible: true },\n    { name: 'entity', compressible: false },\n    { name: 'fk', compressible: false },\n  ]);\n};\n\n// const { ID_COLUMN: id, FIELD_COLUMN: field, ORDER_COLUMN: order } = identifiers;\n\nexport type LoadedContentTypeModel = Struct.ContentTypeSchema &\n  Required<Pick<Struct.ContentTypeSchema, 'collectionName' | 'uid' | 'modelName'>> &\n  Pick<Model, 'lifecycles'>;\n\n// Transforms an attribute (particularly for relation types) into the format that strapi/database accepts\nexport const transformAttribute = (\n  name: string,\n  attribute: Schema.Attribute.AnyAttribute,\n  contentType: LoadedContentTypeModel,\n  identifiers: Identifiers\n) => {\n  switch (attribute.type) {\n    case 'media': {\n      return {\n        type: 'relation',\n        relation: attribute.multiple === true ? 'morphMany' : 'morphOne',\n        target: 'plugin::upload.file',\n        morphBy: 'related',\n      };\n    }\n    case 'component': {\n      const joinTableName = getComponentJoinTableName(contentType.collectionName, identifiers);\n      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);\n      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);\n      const compTypeColumn = getComponentTypeColumn(identifiers);\n      return {\n        type: 'relation',\n        relation: attribute.repeatable === true ? 'oneToMany' : 'oneToOne',\n        target: attribute.component,\n\n        // We need the join table name to be deterministic,\n        // We need to allow passing the join table name as an option\n        joinTable: {\n          name: joinTableName,\n          joinColumn: {\n            name: joinColumnEntityName,\n            referencedColumn: identifiers.ID_COLUMN,\n          },\n          inverseJoinColumn: {\n            name: joinColumnInverseName,\n            referencedColumn: identifiers.ID_COLUMN,\n          },\n          on: {\n            field: name,\n          },\n          orderColumnName: identifiers.ORDER_COLUMN,\n          orderBy: {\n            order: 'asc',\n          },\n          pivotColumns: [\n            joinColumnEntityName,\n            joinColumnInverseName,\n            identifiers.FIELD_COLUMN,\n            compTypeColumn,\n          ],\n        },\n      };\n    }\n    case 'dynamiczone': {\n      const joinTableName = getDzJoinTableName(contentType.collectionName, identifiers);\n      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);\n      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);\n      const compTypeColumn = getComponentTypeColumn(identifiers);\n\n      return {\n        type: 'relation',\n        relation: 'morphToMany',\n        // TODO: handle restrictions at some point\n        // target: attribute.components,\n        joinTable: {\n          name: joinTableName,\n          joinColumn: {\n            name: joinColumnEntityName,\n            referencedColumn: identifiers.ID_COLUMN,\n          },\n          morphColumn: {\n            idColumn: {\n              name: joinColumnInverseName,\n              referencedColumn: identifiers.ID_COLUMN,\n            },\n            typeColumn: {\n              name: compTypeColumn,\n            },\n            typeField: '__component',\n          },\n          on: {\n            field: name,\n          },\n          orderBy: {\n            order: 'asc',\n          },\n          pivotColumns: [\n            joinColumnEntityName,\n            joinColumnInverseName,\n            identifiers.FIELD_COLUMN,\n            compTypeColumn,\n          ],\n        },\n      };\n    }\n    default: {\n      return attribute;\n    }\n  }\n};\n\nexport const transformAttributes = (\n  contentType: LoadedContentTypeModel,\n  identifiers: Identifiers\n) => {\n  return Object.keys(contentType.attributes! || {}).reduce((attrs, attrName) => {\n    return {\n      ...attrs,\n      [attrName]: transformAttribute(\n        attrName,\n        contentType.attributes[attrName]!,\n        contentType,\n        identifiers\n      ),\n    };\n  }, {});\n};\n\nexport const hasComponentsOrDz = (\n  contentType: LoadedContentTypeModel\n): contentType is LoadedContentTypeModel & { type: 'dynamiczone' | 'component' } => {\n  return Object.values(contentType.attributes || {}).some(\n    (({ type }: { type: string }) => type === 'dynamiczone' || type === 'component') as any\n  );\n};\n\nexport const createDocumentId = createId;\n\nconst createCompoLinkModel = (\n  contentType: LoadedContentTypeModel,\n  identifiers: Identifiers\n): Model => {\n  const name = getComponentJoinTableName(contentType.collectionName, identifiers);\n\n  const entityId = getComponentJoinColumnEntityName(identifiers);\n  const componentId = getComponentJoinColumnInverseName(identifiers);\n  const compTypeColumn = getComponentTypeColumn(identifiers);\n  const fkIndex = getComponentFkIndexName(contentType.collectionName, identifiers);\n\n  return {\n    // TODO: make sure there can't be any conflicts with a prefix\n    singularName: name,\n    uid: name,\n    tableName: name,\n    attributes: {\n      [identifiers.ID_COLUMN]: {\n        type: 'increments',\n      },\n      [entityId]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [componentId]: {\n        type: 'integer',\n        column: {\n          unsigned: true,\n        },\n      },\n      [compTypeColumn]: {\n        type: 'string',\n      },\n      [identifiers.FIELD_COLUMN]: {\n        type: 'string',\n      },\n      [identifiers.ORDER_COLUMN]: {\n        type: 'float',\n        column: {\n          unsigned: true,\n          defaultTo: null,\n        },\n      },\n    },\n    indexes: [\n      {\n        name: identifiers.getIndexName([contentType.collectionName, identifiers.FIELD_COLUMN]),\n        columns: [identifiers.FIELD_COLUMN],\n      },\n      {\n        name: identifiers.getIndexName([contentType.collectionName, compTypeColumn]),\n        columns: [compTypeColumn],\n      },\n      {\n        name: fkIndex,\n        columns: [entityId],\n      },\n      {\n        // NOTE: since we don't include attribute names, we need to be careful not to create another unique index\n        name: identifiers.getUniqueIndexName([contentType.collectionName]),\n        columns: [entityId, componentId, identifiers.FIELD_COLUMN, compTypeColumn],\n        type: 'unique',\n      },\n    ],\n    foreignKeys: [\n      {\n        name: fkIndex,\n        columns: [entityId],\n        referencedColumns: [identifiers.ID_COLUMN],\n        referencedTable: identifiers.getTableName(contentType.collectionName),\n        onDelete: 'CASCADE',\n      },\n    ],\n  };\n};\n\nexport const transformContentTypesToModels = (\n  contentTypes: LoadedContentTypeModel[],\n  identifiers: Identifiers\n): Model[] => {\n  const models: Model[] = [];\n\n  contentTypes.forEach((contentType) => {\n    assert(contentType.collectionName, 'Content type \"collectionName\" is required');\n    assert(contentType.modelName, 'Content type \"modelName\" is required');\n    assert(contentType.uid, 'Content type \"uid\" is required');\n\n    // Add document id to content types\n    // as it is not documented\n    const documentIdAttribute: Record<string, Schema.Attribute.AnyAttribute> =\n      contentType.modelType === 'contentType'\n        ? { documentId: { type: 'string', default: createDocumentId } }\n        : {};\n\n    // TODO: this needs to be combined with getReservedNames, we should not be maintaining two lists\n    // Prevent user from creating a documentId attribute\n    const reservedAttributeNames = ['document_id', identifiers.ID_COLUMN];\n    Object.keys(contentType.attributes || {}).forEach((attributeName) => {\n      const snakeCasedAttributeName = _.snakeCase(attributeName);\n      if (reservedAttributeNames.includes(snakeCasedAttributeName)) {\n        throw new Error(\n          `The attribute \"${attributeName}\" is reserved and cannot be used in a model. Please rename \"${contentType.modelName}\" attribute \"${attributeName}\" to something else.`\n        );\n      }\n    });\n\n    if (hasComponentsOrDz(contentType)) {\n      const compoLinkModel = createCompoLinkModel(contentType, identifiers);\n      models.push(compoLinkModel);\n    }\n\n    const model: Model = {\n      uid: contentType.uid,\n      singularName: contentType.modelName,\n      tableName: contentType.collectionName, // This gets shortened in metadata.loadModels(), so we don't shorten here or it will happen twice\n      attributes: {\n        [identifiers.ID_COLUMN]: {\n          type: 'increments',\n        },\n        ...documentIdAttribute,\n        ...transformAttributes(contentType, identifiers),\n      },\n      indexes: contentType.indexes as Model['indexes'],\n      foreignKeys: contentType.foreignKeys as Model['foreignKeys'],\n      lifecycles: contentType?.lifecycles ?? {},\n    };\n\n    // Add indexes to model\n    if (contentType.modelType === 'contentType') {\n      model.indexes = [\n        ...(model.indexes || []),\n        {\n          name: identifiers.getIndexName([contentType.collectionName, 'documents']),\n          // Filter attributes that are not in the schema\n          columns: ['documentId', 'locale', 'publishedAt']\n            .filter((n) => model.attributes[n])\n            .map((name) => identifiers.getColumnName(_.snakeCase(name))),\n        },\n      ];\n    }\n\n    models.push(model);\n  });\n\n  return models;\n};\n"],"names":["getComponentJoinTableName","collectionName","identifiers","getNameFromTokens","name","compressible","shortName","getDzJoinTableName","getComponentJoinColumnEntityName","getComponentJoinColumnInverseName","getComponentTypeColumn","getComponentFkIndexName","contentType","transformAttribute","attribute","type","relation","multiple","target","morphBy","joinTableName","joinColumnEntityName","joinColumnInverseName","compTypeColumn","repeatable","component","joinTable","joinColumn","referencedColumn","ID_COLUMN","inverseJoinColumn","on","field","orderColumnName","ORDER_COLUMN","orderBy","order","pivotColumns","FIELD_COLUMN","morphColumn","idColumn","typeColumn","typeField","transformAttributes","Object","keys","attributes","reduce","attrs","attrName","hasComponentsOrDz","values","some","createDocumentId","createId","createCompoLinkModel","entityId","componentId","fkIndex","singularName","uid","tableName","column","unsigned","defaultTo","indexes","getIndexName","columns","getUniqueIndexName","foreignKeys","referencedColumns","referencedTable","getTableName","onDelete","transformContentTypesToModels","contentTypes","models","forEach","assert","modelName","documentIdAttribute","modelType","documentId","default","reservedAttributeNames","attributeName","snakeCasedAttributeName","_","snakeCase","includes","Error","compoLinkModel","push","model","lifecycles","filter","n","map","getColumnName"],"mappings":"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"}