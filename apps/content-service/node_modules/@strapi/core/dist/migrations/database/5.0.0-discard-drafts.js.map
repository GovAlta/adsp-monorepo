{"version":3,"file":"5.0.0-discard-drafts.js","sources":["../../../src/migrations/database/5.0.0-discard-drafts.ts"],"sourcesContent":["/**\n * This migration is responsible for creating the draft counterpart for all the entries that were in a published state.\n *\n * In v4, entries could either be in a draft or published state, but not both at the same time.\n * In v5, we introduced the concept of document, and an entry can be in a draft or published state.\n *\n * This means the migration needs to create the draft counterpart if an entry was published.\n *\n * This migration performs the following steps:\n * 1. Creates draft entries for all published entries, without it's components, dynamic zones or relations.\n * 2. Using the document service, discard those same drafts to copy its relations.\n */\n\n/* eslint-disable no-continue */\nimport type { UID } from '@strapi/types';\nimport type { Database, Migration } from '@strapi/database';\nimport { async, contentTypes } from '@strapi/utils';\nimport { createDocumentService } from '../../services/document-service';\n\ntype DocumentVersion = { documentId: string; locale: string };\ntype Knex = Parameters<Migration['up']>[0];\n\n/**\n * Check if the model has draft and publish enabled.\n */\nconst hasDraftAndPublish = async (trx: Knex, meta: any) => {\n  const hasTable = await trx.schema.hasTable(meta.tableName);\n\n  if (!hasTable) {\n    return false;\n  }\n\n  const uid = meta.uid as UID.ContentType;\n  const model = strapi.getModel(uid);\n  const hasDP = contentTypes.hasDraftAndPublish(model);\n  if (!hasDP) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Copy all the published entries to draft entries, without it's components, dynamic zones or relations.\n * This ensures all necessary draft's exist before copying it's relations.\n */\nasync function copyPublishedEntriesToDraft({\n  db,\n  trx,\n  uid,\n}: {\n  db: Database;\n  trx: Knex;\n  uid: string;\n}) {\n  // Extract all scalar attributes to use in the insert query\n  const meta = db.metadata.get(uid);\n\n  // Get scalar attributes that will be copied over the new draft\n  const scalarAttributes = Object.values(meta.attributes).reduce((acc, attribute: any) => {\n    if (['id'].includes(attribute.columnName)) {\n      return acc;\n    }\n\n    if (contentTypes.isScalarAttribute(attribute)) {\n      acc.push(attribute.columnName);\n    }\n\n    return acc;\n  }, [] as string[]);\n\n  /**\n   * Query to copy the published entries into draft entries.\n   *\n   * INSERT INTO tableName (columnName1, columnName2, columnName3, ...)\n   * SELECT columnName1, columnName2, columnName3, ...\n   * FROM tableName\n   */\n  await trx\n    // INSERT INTO tableName (columnName1, columnName2, columnName3, ...)\n    .into(\n      trx.raw(`?? (${scalarAttributes.map(() => `??`).join(', ')})`, [\n        meta.tableName,\n        ...scalarAttributes,\n      ])\n    )\n    .insert((subQb: typeof trx) => {\n      // SELECT columnName1, columnName2, columnName3, ...\n      subQb\n        .select(\n          ...scalarAttributes.map((att: string) => {\n            // Override 'publishedAt' and 'updatedAt' attributes\n            if (att === 'published_at') {\n              return trx.raw('NULL as ??', 'published_at');\n            }\n\n            return att;\n          })\n        )\n        .from(meta.tableName)\n        // Only select entries that were published\n        .whereNotNull('published_at');\n    });\n}\n\n/**\n * Load a batch of versions to discard.\n *\n * Versions with only a draft version will be ignored.\n * Only versions with a published version (which always have a draft version) will be discarded.\n */\nexport async function* getBatchToDiscard({\n  db,\n  trx,\n  uid,\n  defaultBatchSize = 1000,\n}: {\n  db: Database;\n  trx: Knex;\n  uid: string;\n  defaultBatchSize?: number;\n}) {\n  const client = db.config.connection.client;\n  const isSQLite =\n    typeof client === 'string' && ['sqlite', 'sqlite3', 'better-sqlite3'].includes(client);\n\n  // The SQLite documentation states that the maximum number of terms in a\n  // compound SELECT statement is 500 by default.\n  // See: https://www.sqlite.org/limits.html\n  // To ensure a successful migration, we limit the batch size to 500 for SQLite.\n  const batchSize = isSQLite ? Math.min(defaultBatchSize, 500) : defaultBatchSize;\n  let offset = 0;\n  let hasMore = true;\n\n  while (hasMore) {\n    // Look for the published entries to discard\n    const batch: DocumentVersion[] = await db\n      .queryBuilder(uid)\n      .select(['id', 'documentId', 'locale'])\n      .where({ publishedAt: { $ne: null } })\n      .limit(batchSize)\n      .offset(offset)\n      .orderBy('id')\n      .transacting(trx)\n      .execute();\n\n    if (batch.length < batchSize) {\n      hasMore = false;\n    }\n\n    offset += batchSize;\n    yield batch;\n  }\n}\n\n/**\n * 2 pass migration to create the draft entries for all the published entries.\n * And then discard the drafts to copy the relations.\n */\nconst migrateUp = async (trx: Knex, db: Database) => {\n  const dpModels = [];\n  for (const meta of db.metadata.values()) {\n    const hasDP = await hasDraftAndPublish(trx, meta);\n    if (hasDP) {\n      dpModels.push(meta);\n    }\n  }\n\n  /**\n   * Create plain draft entries for all the entries that were published.\n   */\n  for (const model of dpModels) {\n    await copyPublishedEntriesToDraft({ db, trx, uid: model.uid });\n  }\n\n  /**\n   * Discard the drafts will copy the relations from the published entries to the newly created drafts.\n   *\n   * Load a batch of entries (batched to prevent loading millions of rows at once ),\n   * and discard them using the document service.\n   *\n   * NOTE: This is using a custom document service without any validations,\n   *       to prevent the migration from failing if users already had invalid data in V4.\n   *       E.g. @see https://github.com/strapi/strapi/issues/21583\n   */\n  const documentService = createDocumentService(strapi, {\n    async validateEntityCreation(_, data) {\n      return data;\n    },\n    async validateEntityUpdate(_, data) {\n      // Data can be partially empty on partial updates\n      // This migration doesn't trigger any update (or partial update),\n      // so it's safe to return the data as is.\n      return data as any;\n    },\n  });\n\n  for (const model of dpModels) {\n    const discardDraft = async (entry: DocumentVersion) =>\n      documentService(model.uid as UID.ContentType).discardDraft({\n        documentId: entry.documentId,\n        locale: entry.locale,\n      });\n\n    for await (const batch of getBatchToDiscard({ db, trx, uid: model.uid })) {\n      // NOTE: concurrency had to be disabled to prevent a race condition with self-references\n      // TODO: improve performance in a safe way\n      await async.map(batch, discardDraft, { concurrency: 1 });\n    }\n  }\n};\n\nexport const discardDocumentDrafts: Migration = {\n  name: 'core::5.0.0-discard-drafts',\n  async up(trx, db) {\n    await migrateUp(trx, db);\n  },\n  async down() {\n    throw new Error('not implemented');\n  },\n};\n"],"names":["hasDraftAndPublish","trx","meta","hasTable","schema","tableName","uid","model","strapi","getModel","hasDP","contentTypes","copyPublishedEntriesToDraft","db","metadata","get","scalarAttributes","Object","values","attributes","reduce","acc","attribute","includes","columnName","isScalarAttribute","push","into","raw","map","join","insert","subQb","select","att","from","whereNotNull","getBatchToDiscard","defaultBatchSize","client","config","connection","isSQLite","batchSize","Math","min","offset","hasMore","batch","queryBuilder","where","publishedAt","$ne","limit","orderBy","transacting","execute","length","migrateUp","dpModels","documentService","createDocumentService","validateEntityCreation","_","data","validateEntityUpdate","discardDraft","entry","documentId","locale","async","concurrency","discardDocumentDrafts","name","up","down","Error"],"mappings":"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"}