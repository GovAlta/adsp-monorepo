{"version":3,"file":"utils.mjs","sources":["../../../../src/file/providers/source/utils.ts"],"sourcesContent":["import path from 'path';\n\n/**\n * Note: in versions of the transfer engine <=4.9.0, exports were generated with windows paths\n * on Windows systems, and posix paths on posix systems.\n *\n * We now store all paths as posix, but need to leave a separator conversion for legacy purposes, and to\n * support manually-created tar files coming from Windows systems (ie, if a user creates a\n * backup file with a windows tar tool rather than using the `export` command)\n *\n * Because of this, export/import files may never contain files with a forward slash in the name, even escaped\n *\n * */\n\n/**\n * Check if the directory of a given filePath (which can be either posix or win32) resolves to the same as the given posix-format path posixDirName\n * We must be able to assume the first argument is a path to a directory and the second is a path to a file, otherwise path.dirname will interpret a path without any slashes as the filename\n *\n * @param {string} posixDirName A posix path pointing to a directory\n * @param {string} filePath an unknown filesystem path pointing to a file\n * @returns {boolean} is the file located in the given directory\n */\nexport const isFilePathInDirname = (posixDirName: string, filePath: string) => {\n  const normalizedDir = path.posix.dirname(unknownPathToPosix(filePath));\n  return isPathEquivalent(posixDirName, normalizedDir);\n};\n\n/**\n *  Check if two paths that can be either in posix or win32 format resolves to the same file\n *\n * @param {string} pathA a path that may be either win32 or posix\n * @param {string} pathB a path that may be either win32 or posix\n *\n * @returns {boolean} do paths point to the same place\n */\nexport const isPathEquivalent = (pathA: string, pathB: string) => {\n  // Check if paths appear to be win32 or posix, and if win32 convert to posix\n  const normalizedPathA = path.posix.normalize(unknownPathToPosix(pathA));\n  const normalizedPathB = path.posix.normalize(unknownPathToPosix(pathB));\n\n  return !path.posix.relative(normalizedPathB, normalizedPathA).length;\n};\n\n/**\n *  Convert an unknown format path (win32 or posix) to a posix path\n *\n * @param {string} filePath a path that may be either win32 or posix\n *\n * @returns {string} a posix path\n */\nexport const unknownPathToPosix = (filePath: string) => {\n  // if it includes a forward slash, it must be posix already -- we will not support win32 with mixed path separators\n  if (filePath.includes(path.posix.sep)) {\n    return filePath;\n  }\n\n  return path.normalize(filePath).split(path.win32.sep).join(path.posix.sep);\n};\n"],"names":["isFilePathInDirname","posixDirName","filePath","normalizedDir","path","posix","dirname","unknownPathToPosix","isPathEquivalent","pathA","pathB","normalizedPathA","normalize","normalizedPathB","relative","length","includes","sep","split","win32","join"],"mappings":";;AAEA;;;;;;;;;;;;;;;;;AAmBC,IACM,MAAMA,mBAAsB,GAAA,CAACC,YAAsBC,EAAAA,QAAAA,GAAAA;AACxD,IAAA,MAAMC,gBAAgBC,IAAKC,CAAAA,KAAK,CAACC,OAAO,CAACC,kBAAmBL,CAAAA,QAAAA,CAAAA,CAAAA;AAC5D,IAAA,OAAOM,iBAAiBP,YAAcE,EAAAA,aAAAA,CAAAA;AACxC;AAEA;;;;;;;AAOC,IACM,MAAMK,gBAAmB,GAAA,CAACC,KAAeC,EAAAA,KAAAA,GAAAA;;AAE9C,IAAA,MAAMC,kBAAkBP,IAAKC,CAAAA,KAAK,CAACO,SAAS,CAACL,kBAAmBE,CAAAA,KAAAA,CAAAA,CAAAA;AAChE,IAAA,MAAMI,kBAAkBT,IAAKC,CAAAA,KAAK,CAACO,SAAS,CAACL,kBAAmBG,CAAAA,KAAAA,CAAAA,CAAAA;IAEhE,OAAO,CAACN,KAAKC,KAAK,CAACS,QAAQ,CAACD,eAAAA,EAAiBF,iBAAiBI,MAAM;AACtE;AAEA;;;;;;IAOaR,MAAAA,kBAAAA,GAAqB,CAACL,QAAAA,GAAAA;;AAEjC,IAAA,IAAIA,SAASc,QAAQ,CAACZ,KAAKC,KAAK,CAACY,GAAG,CAAG,EAAA;QACrC,OAAOf,QAAAA;AACT;AAEA,IAAA,OAAOE,KAAKQ,SAAS,CAACV,QAAUgB,CAAAA,CAAAA,KAAK,CAACd,IAAKe,CAAAA,KAAK,CAACF,GAAG,EAAEG,IAAI,CAAChB,IAAKC,CAAAA,KAAK,CAACY,GAAG,CAAA;AAC3E;;;;"}