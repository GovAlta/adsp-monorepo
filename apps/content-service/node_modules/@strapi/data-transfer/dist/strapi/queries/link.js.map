{"version":3,"file":"link.js","sources":["../../../src/strapi/queries/link.ts"],"sourcesContent":["import type { Knex } from 'knex';\nimport { clone, isNil } from 'lodash/fp';\nimport type { Core } from '@strapi/types';\n\nimport { ILink } from '../../../types';\n\n// TODO: Remove any types when we'll have types for DB metadata\n\nexport const createLinkQuery = (strapi: Core.Strapi, trx?: Knex.Transaction) => {\n  const query = () => {\n    const { connection } = strapi.db;\n\n    // TODO: Export utils from database and use the addSchema that is already written\n    const addSchema = (tableName: string) => {\n      const schemaName = connection.client.connectionSettings.schema;\n      return schemaName ? `${schemaName}.${tableName}` : tableName;\n    };\n\n    async function* generateAllForAttribute(uid: string, fieldName: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      if (!(fieldName in attributes)) {\n        throw new Error(`${fieldName} is not a valid relational attribute name`);\n      }\n\n      const attribute = attributes[fieldName];\n\n      const kind = getLinkKind(attribute, uid);\n      const { relation, target } = attribute;\n\n      // The relation is stored in the same table\n      // TODO: handle manyToOne joinColumn\n      if (attribute.joinColumn) {\n        const joinColumnName: string = attribute.joinColumn.name;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', joinColumnName)\n          .from(addSchema(metadata.tableName));\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[joinColumnName];\n\n          if (ref !== null) {\n            yield {\n              kind,\n              relation,\n              left: { type: uid, ref: entry.id, field: fieldName },\n              right: { type: target, ref },\n            };\n          }\n        }\n      }\n\n      // The relation uses a join table\n      if (attribute.joinTable) {\n        const {\n          name,\n          joinColumn,\n          inverseJoinColumn,\n          orderColumnName,\n          morphColumn,\n          inverseOrderColumnName,\n        } = attribute.joinTable;\n\n        const qb = connection.queryBuilder().from(addSchema(name));\n\n        type Columns = {\n          left: { ref: string | null; order?: string };\n          right: { ref: string | null; order?: string; type?: string; field?: string };\n        };\n\n        const columns: Columns = {\n          left: { ref: null },\n          right: { ref: null },\n        };\n\n        const left: Partial<ILink['left']> = { type: uid, field: fieldName };\n        const right: Partial<ILink['right']> = {};\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          right.type = attribute.target;\n          right.field = attribute.inversedBy;\n\n          columns.left.ref = joinColumn.name;\n          columns.right.ref = inverseJoinColumn.name;\n\n          if (orderColumnName) {\n            columns.left.order = orderColumnName as string;\n          }\n\n          if (inverseOrderColumnName) {\n            columns.right.order = inverseOrderColumnName as string;\n          }\n        }\n\n        if (kind === 'relation.morph') {\n          columns.left.ref = joinColumn.name;\n\n          columns.right.ref = morphColumn.idColumn.name;\n          columns.right.type = morphColumn.typeColumn.name;\n          columns.right.field = 'field';\n          columns.right.order = 'order';\n        }\n\n        const validColumns = [\n          // Left\n          columns.left.ref,\n          columns.left.order,\n          // Right\n          columns.right.ref,\n          columns.right.type,\n          columns.right.field,\n          columns.right.order,\n        ].filter((column: string | null | undefined) => !isNil(column));\n\n        qb.select(validColumns);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        // TODO: stream the query to improve performances\n        const entries = await qb;\n\n        for (const entry of entries) {\n          if (columns.left.ref) {\n            left.ref = entry[columns.left.ref];\n          }\n\n          if (columns.right.ref) {\n            right.ref = entry[columns.right.ref];\n          }\n\n          if (columns.left.order) {\n            left.pos = entry[columns.left.order as string];\n          }\n\n          if (columns.right.order) {\n            right.pos = entry[columns.right.order as string];\n          }\n\n          if (columns.right.type) {\n            right.type = entry[columns.right.type as string];\n          }\n\n          if (columns.right.field) {\n            right.field = entry[columns.right.field as string];\n          }\n\n          const link: ILink = {\n            kind,\n            relation,\n            left: clone(left as ILink['left']),\n            right: clone(right as ILink['right']),\n          };\n\n          yield link;\n        }\n      }\n\n      if (attribute.morphColumn) {\n        const { typeColumn, idColumn } = attribute.morphColumn;\n\n        const qb = connection\n          .queryBuilder()\n          .select('id', typeColumn.name, idColumn.name)\n          .from(addSchema(metadata.tableName))\n          .whereNotNull(typeColumn.name)\n          .whereNotNull(idColumn.name);\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        const entries = await qb;\n\n        for (const entry of entries) {\n          const ref = entry[idColumn.name];\n\n          yield {\n            kind,\n            relation,\n            left: { type: uid, ref: entry.id, field: fieldName },\n            right: { type: entry[typeColumn.name], ref },\n          };\n        }\n      }\n    }\n\n    async function* generateAll(uid: string): AsyncGenerator<ILink> {\n      const metadata = strapi.db.metadata.get(uid);\n\n      if (!metadata) {\n        throw new Error(`No metadata found for ${uid}`);\n      }\n\n      const attributes = filterValidRelationalAttributes(metadata.attributes);\n\n      for (const fieldName of Object.keys(attributes)) {\n        for await (const link of generateAllForAttribute(uid, fieldName)) {\n          yield link;\n        }\n      }\n    }\n\n    const insert = async (link: ILink) => {\n      const { kind, left, right } = link;\n\n      const metadata = strapi.db.metadata.get(left.type);\n      const attribute = metadata.attributes[left.field];\n\n      const payload = {};\n\n      /**\n       * This _should_ only happen for attributes that are added dynamically e.g. review-workflow stages\n       * and a user is importing EE data into a CE project.\n       */\n      if (!attribute) {\n        return;\n      }\n\n      if (attribute.type !== 'relation') {\n        throw new Error(`Attribute ${left.field} is not a relation`);\n      }\n\n      if ('joinColumn' in attribute && attribute.joinColumn) {\n        const joinColumnName = attribute.joinColumn.name;\n\n        // Note: this addSchema may not be necessary, but is added for safety\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({ [joinColumnName]: right.ref });\n        if (trx) {\n          qb.transacting(trx);\n        }\n        await qb;\n      }\n\n      if ('joinTable' in attribute && attribute.joinTable) {\n        const { joinTable } = attribute;\n\n        if (joinTable.joinColumn) {\n          Object.assign(payload, { [joinTable.joinColumn.name]: left.ref });\n        }\n\n        const assignInverseColumn = () => {\n          if ('inverseJoinColumn' in joinTable && joinTable.inverseJoinColumn) {\n            Object.assign(payload, {\n              [joinTable.inverseJoinColumn.name]: right.ref,\n            });\n          }\n        };\n\n        const assignOrderColumns = () => {\n          if ('orderColumnName' in joinTable && joinTable.orderColumnName) {\n            Object.assign(payload, { [joinTable.orderColumnName]: left.pos ?? null });\n          }\n\n          if ('inverseOrderColumnName' in joinTable && joinTable.inverseOrderColumnName) {\n            Object.assign(payload, { [joinTable.inverseOrderColumnName]: right.pos ?? null });\n          }\n        };\n\n        const assignMorphColumns = () => {\n          if ('morphColumn' in joinTable && joinTable.morphColumn) {\n            const { idColumn, typeColumn } = joinTable.morphColumn ?? {};\n\n            if (idColumn) {\n              Object.assign(payload, { [idColumn.name]: right.ref });\n            }\n\n            if (typeColumn) {\n              Object.assign(payload, { [typeColumn.name]: right.type });\n            }\n\n            Object.assign(payload, { order: right.pos ?? null, field: right.field ?? null });\n          }\n        };\n\n        if (kind === 'relation.basic' || kind === 'relation.circular') {\n          assignInverseColumn();\n        }\n\n        if (kind === 'relation.morph') {\n          assignMorphColumns();\n        }\n\n        assignOrderColumns();\n        const qb = connection.insert(payload).into(addSchema(joinTable.name));\n        if (trx) {\n          await qb.transacting(trx);\n        }\n      }\n\n      if ('morphColumn' in attribute && attribute.morphColumn) {\n        const { morphColumn } = attribute;\n\n        const qb = connection(addSchema(metadata.tableName))\n          .where('id', left.ref)\n          .update({\n            [morphColumn.idColumn.name]: right.ref,\n            [morphColumn.typeColumn.name]: right.type,\n          });\n\n        if (trx) {\n          qb.transacting(trx);\n        }\n\n        await qb;\n      }\n    };\n\n    return { generateAll, generateAllForAttribute, insert };\n  };\n\n  return query;\n};\n\nexport const filterValidRelationalAttributes = (attributes: Record<string, any>) => {\n  const isOwner = (attribute: any) => {\n    return attribute.owner || (!attribute.mappedBy && !attribute.morphBy);\n  };\n\n  const isComponentLike = (attribute: any) => attribute.joinTable?.name.endsWith('_cmps');\n\n  return Object.entries(attributes)\n    .filter(([, attribute]) => {\n      return attribute.type === 'relation' && isOwner(attribute) && !isComponentLike(attribute);\n    })\n    .reduce<Record<string, any>>((acc, [key, attribute]) => ({ ...acc, [key]: attribute }), {});\n};\n\nconst getLinkKind = (attribute: any, uid: string): ILink['kind'] => {\n  if (attribute.relation.startsWith('morph')) {\n    return 'relation.morph';\n  }\n\n  if (attribute.target === uid) {\n    return 'relation.circular';\n  }\n\n  return 'relation.basic';\n};\n"],"names":["createLinkQuery","strapi","trx","query","connection","db","addSchema","tableName","schemaName","client","connectionSettings","schema","generateAllForAttribute","uid","fieldName","metadata","get","Error","attributes","filterValidRelationalAttributes","attribute","kind","getLinkKind","relation","target","joinColumn","joinColumnName","name","qb","queryBuilder","select","from","transacting","entries","entry","ref","left","type","id","field","right","joinTable","inverseJoinColumn","orderColumnName","morphColumn","inverseOrderColumnName","columns","inversedBy","order","idColumn","typeColumn","validColumns","filter","column","isNil","pos","link","clone","whereNotNull","generateAll","Object","keys","insert","payload","where","update","assign","assignInverseColumn","assignOrderColumns","assignMorphColumns","into","isOwner","owner","mappedBy","morphBy","isComponentLike","endsWith","reduce","acc","key","startsWith"],"mappings":"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"}