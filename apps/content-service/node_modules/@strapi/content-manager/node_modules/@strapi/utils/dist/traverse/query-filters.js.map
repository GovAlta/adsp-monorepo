{"version":3,"file":"query-filters.js","sources":["../../src/traverse/query-filters.ts"],"sourcesContent":["import { curry, isObject, isEmpty, isArray, isNil, cloneDeep, omit } from 'lodash/fp';\n\nimport traverseFactory, { type Parent } from './factory';\n\nconst isObj = (value: unknown): value is Record<string, unknown> => isObject(value);\n\nconst filters = traverseFactory()\n  .intercept(\n    // Intercept filters arrays and apply the traversal to each one individually\n    isArray,\n    async (visitor, options, filters, { recurse }) => {\n      return Promise.all(\n        filters.map((filter, i) => {\n          // In filters, only operators such as $and, $in, $notIn or $or and implicit operators like [...]\n          // can have a value array, thus we can update the raw path but not the attribute one\n          const newPath = options.path\n            ? { ...options.path, raw: `${options.path.raw}[${i}]` }\n            : options.path;\n\n          return recurse(visitor, { ...options, path: newPath }, filter);\n        })\n        // todo: move that to the visitors\n      ).then((res) => res.filter((val) => !(isObject(val) && isEmpty(val))));\n    }\n  )\n  .intercept(\n    // Ignore non object filters and return the value as-is\n    (filters): filters is unknown => !isObject(filters),\n    (_, __, filters) => {\n      return filters;\n    }\n  )\n  // Parse object values\n  .parse(isObj, () => ({\n    transform: cloneDeep,\n\n    remove(key, data) {\n      return omit(key, data);\n    },\n\n    set(key, value, data) {\n      return { ...data, [key]: value };\n    },\n\n    keys(data) {\n      return Object.keys(data);\n    },\n\n    get(key, data) {\n      return data[key];\n    },\n  }))\n  // Ignore null or undefined values\n  .ignore(({ value }) => isNil(value))\n  // Recursion on operators (non attributes)\n  .on(\n    ({ attribute }) => isNil(attribute),\n    async ({ key, visitor, path, value, schema, getModel, attribute }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n\n      set(key, await recurse(visitor, { schema, path, getModel, parent }, value));\n    }\n  )\n  // Handle relation recursion\n  .onRelation(\n    async ({ key, attribute, visitor, path, value, schema, getModel }, { set, recurse }) => {\n      const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');\n\n      if (isMorphRelation) {\n        return;\n      }\n\n      const parent: Parent = { key, path, schema, attribute };\n\n      const targetSchemaUID = attribute.target;\n      const targetSchema = getModel(targetSchemaUID!);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  .onComponent(\n    async ({ key, attribute, visitor, path, schema, value, getModel }, { set, recurse }) => {\n      const parent: Parent = { key, path, schema, attribute };\n      const targetSchema = getModel(attribute.component);\n\n      const newValue = await recurse(\n        visitor,\n        { schema: targetSchema, path, getModel, parent },\n        value\n      );\n\n      set(key, newValue);\n    }\n  )\n  // Handle media recursion\n  .onMedia(async ({ key, visitor, path, schema, attribute, value, getModel }, { set, recurse }) => {\n    const parent: Parent = { key, path, schema, attribute };\n\n    const targetSchemaUID = 'plugin::upload.file';\n    const targetSchema = getModel(targetSchemaUID);\n\n    const newValue = await recurse(\n      visitor,\n      { schema: targetSchema, path, getModel, parent },\n      value\n    );\n\n    set(key, newValue);\n  });\n\nexport default curry(filters.traverse);\n"],"names":["isObj","value","isObject","filters","traverseFactory","intercept","isArray","visitor","options","recurse","Promise","all","map","filter","i","newPath","path","raw","then","res","val","isEmpty","_","__","parse","transform","cloneDeep","remove","key","data","omit","set","keys","Object","get","ignore","isNil","on","attribute","schema","getModel","parent","onRelation","isMorphRelation","relation","toLowerCase","startsWith","targetSchemaUID","target","targetSchema","newValue","onComponent","component","onMedia","curry","traverse"],"mappings":"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"}