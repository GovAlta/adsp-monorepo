{"version":3,"file":"data.mjs","sources":["../../../../../admin/src/pages/EditView/utils/data.ts"],"sourcesContent":["import { createRulesEngine } from '@strapi/admin/strapi-admin';\nimport { generateNKeysBetween } from 'fractional-indexing';\nimport pipe from 'lodash/fp/pipe';\n\nimport { DOCUMENT_META_FIELDS } from '../../../constants/attributes';\n\nimport type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\nimport type { Schema, UID } from '@strapi/types';\n\n/* -------------------------------------------------------------------------------------------------\n * traverseData\n * -----------------------------------------------------------------------------------------------*/\n\n// Make only attributes required since it's the only one Content History has\ntype PartialSchema = Partial<Schema.Schema> & Pick<Schema.Schema, 'attributes'>;\n\ntype Predicate = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  attribute: TAttribute,\n  value: Schema.Attribute.Value<TAttribute>\n) => boolean;\ntype Transform = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  value: any,\n  attribute: TAttribute\n) => any;\ntype AnyData = Omit<Document, 'id'>;\n\nconst BLOCK_LIST_ATTRIBUTE_KEYS = ['__component', '__temp_key__'];\n\n/**\n * @internal This function is used to traverse the data and transform the values.\n * Given a predicate function, it will transform the value (using the given transform function)\n * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,\n * it will recursively traverse those data structures as well.\n *\n * It is possible to break the ContentManager by using this function incorrectly, for example,\n * if you transform a number into a string but the attribute type is a number, the ContentManager\n * will not be able to save the data and the Form will likely crash because the component it's\n * passing the data too won't succesfully be able to handle the value.\n */\nconst traverseData =\n  (predicate: Predicate, transform: Transform) =>\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (data: AnyData = {}) => {\n    const traverse = (datum: AnyData, attributes: Schema.Schema['attributes']) => {\n      return Object.entries(datum).reduce<AnyData>((acc, [key, value]) => {\n        const attribute = attributes[key];\n\n        /**\n         * If the attribute is a block list attribute, we don't want to transform it.\n         * We also don't want to transform null or undefined values.\n         */\n        if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {\n          acc[key] = value;\n          return acc;\n        }\n\n        if (attribute.type === 'component') {\n          if (attribute.repeatable) {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n            acc[key] = componentValue.map((componentData) =>\n              traverse(componentData, components[attribute.component]?.attributes ?? {})\n            );\n          } else {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, false>>;\n\n            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});\n          }\n        } else if (attribute.type === 'dynamiczone') {\n          const dynamicZoneValue = (\n            predicate(attribute, value) ? transform(value, attribute) : value\n          ) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n          acc[key] = dynamicZoneValue.map((componentData) =>\n            traverse(componentData, components[componentData.__component]?.attributes ?? {})\n          );\n        } else if (predicate(attribute, value)) {\n          acc[key] = transform(value, attribute);\n        } else {\n          acc[key] = value;\n        }\n\n        return acc;\n      }, {});\n    };\n\n    return traverse(data, schema.attributes);\n  };\n\n/* -------------------------------------------------------------------------------------------------\n * removeProhibitedFields\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal Removes all the fields that are not allowed.\n */\nconst removeProhibitedFields = (prohibitedFields: Schema.Attribute.Kind[]) =>\n  traverseData(\n    (attribute) => prohibitedFields.includes(attribute.type),\n    () => ''\n  );\n\n/* -------------------------------------------------------------------------------------------------\n * prepareRelations\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Sets all relation values to an empty array.\n */\nconst prepareRelations = traverseData(\n  (attribute) => attribute.type === 'relation',\n  () => ({\n    connect: [],\n    disconnect: [],\n  })\n);\n\n/* -------------------------------------------------------------------------------------------------\n * prepareTempKeys\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us\n * a stable identifier regardless of its ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = traverseData(\n  (attribute) =>\n    (attribute.type === 'component' && attribute.repeatable) || attribute.type === 'dynamiczone',\n  (data) => {\n    if (Array.isArray(data) && data.length > 0) {\n      const keys = generateNKeysBetween(undefined, undefined, data.length);\n\n      return data.map((datum, index) => ({\n        ...datum,\n        __temp_key__: keys[index],\n      }));\n    }\n\n    return data;\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * removeFieldsThatDontExistOnSchema\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),\n * as such we don't need to traverse the components to remove them.\n */\nconst removeFieldsThatDontExistOnSchema = (schema: PartialSchema) => (data: AnyData) => {\n  const schemaKeys = Object.keys(schema.attributes);\n  const dataKeys = Object.keys(data);\n\n  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));\n\n  const revisedData = [...keysToRemove, ...DOCUMENT_META_FIELDS].reduce((acc, key) => {\n    delete acc[key];\n\n    return acc;\n  }, structuredClone(data));\n\n  return revisedData;\n};\n\n/**\n * @internal\n * @description We need to remove null fields from the data-structure because it will pass it\n * to the specific inputs breaking them as most would prefer empty strings or `undefined` if\n * they're controlled / uncontrolled.\n */\nconst removeNullValues = (data: AnyData) => {\n  return Object.entries(data).reduce<AnyData>((acc, [key, value]) => {\n    if (value === null) {\n      return acc;\n    }\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n};\n\n/* -------------------------------------------------------------------------------------------------\n * transformDocuments\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Takes a document data structure (this could be from the API or a default form structure)\n * and applies consistent data transformations to it. This is also used when we add new components to the\n * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.\n */\nconst transformDocument =\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (document: AnyData) => {\n    const transformations = pipe(\n      removeFieldsThatDontExistOnSchema(schema),\n      removeProhibitedFields(['password'])(schema, components),\n      removeNullValues,\n      prepareRelations(schema, components),\n      prepareTempKeys(schema, components)\n    );\n\n    return transformations(document);\n  };\n\ntype HandleOptions = {\n  schema?: Schema.ContentType | Schema.Component;\n  initialValues?: AnyData;\n  components?: Record<string, Schema.Component>;\n};\n\ntype RemovedFieldPath = string;\n\n/**\n * @internal\n * @description Finds the initial value for a component or dynamic zone item (based on its __temp_key__ and not its index).\n * @param initialValue - The initial values object.\n * @param item - The item to find the initial value for.\n * @returns The initial value for the item.\n */\nconst getItemInitialValue = (initialValue: AnyData, item: AnyData) => {\n  if (initialValue && Array.isArray(initialValue)) {\n    const matchingInitialItem = initialValue.find(\n      (initialItem) => initialItem.__temp_key__ === item.__temp_key__\n    );\n    if (matchingInitialItem) {\n      return matchingInitialItem;\n    }\n  }\n  return {};\n};\n\n/**\n * Removes values from the data object if their corresponding attribute has a\n * visibility condition that evaluates to false.\n *\n * @param {object} schema - The content type schema (with attributes).\n * @param {object} data - The data object to filter based on visibility.\n * @returns {object} A new data object with only visible fields retained.\n */\nconst handleInvisibleAttributes = (\n  data: AnyData,\n  { schema, initialValues = {}, components = {} }: HandleOptions,\n  path: string[] = [],\n  removedAttributes: RemovedFieldPath[] = []\n): {\n  data: AnyData;\n  removedAttributes: RemovedFieldPath[];\n} => {\n  if (!schema?.attributes) return { data, removedAttributes };\n\n  const rulesEngine = createRulesEngine();\n  const result: AnyData = {};\n\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\n    const fullPath = [...path, attrName].join('.');\n    const condition = attrDef?.conditions?.visible;\n    const isVisible = condition ? rulesEngine.evaluate(condition, { ...data, ...result }) : true;\n\n    if (!isVisible) {\n      removedAttributes.push(fullPath);\n      continue;\n    }\n\n    const userProvided = Object.prototype.hasOwnProperty.call(data, attrName);\n    const currentValue = userProvided ? data[attrName] : undefined;\n    const initialValue = initialValues?.[attrName];\n\n    // ðŸ”¹ Handle components\n    if (attrDef.type === 'component') {\n      const compSchema = components[attrDef.component];\n      const value = currentValue === undefined ? initialValue : currentValue;\n\n      if (!value) {\n        result[attrName] = attrDef.repeatable ? [] : null;\n        continue;\n      }\n\n      if (attrDef.repeatable && Array.isArray(value)) {\n        result[attrName] = value.map((item) => {\n          const componentInitialValue = getItemInitialValue(initialValue, item);\n\n          return handleInvisibleAttributes(\n            item,\n            {\n              schema: compSchema,\n              initialValues: componentInitialValue,\n              components,\n            },\n            [...path, `${attrName}[${item.__temp_key__}]`],\n            removedAttributes\n          ).data;\n        });\n      } else {\n        result[attrName] = handleInvisibleAttributes(\n          value,\n          {\n            schema: compSchema,\n            initialValues: initialValue ?? {},\n            components,\n          },\n          [...path, attrName],\n          removedAttributes\n        ).data;\n      }\n\n      continue;\n    }\n\n    // ðŸ”¸ Handle dynamic zones\n    if (attrDef.type === 'dynamiczone') {\n      if (!Array.isArray(currentValue)) {\n        result[attrName] = [];\n        continue;\n      }\n\n      result[attrName] = currentValue.map((dzItem) => {\n        const compUID = dzItem?.__component;\n        const compSchema = components[compUID];\n\n        const componentInitialValue = getItemInitialValue(initialValue, dzItem);\n\n        const cleaned = handleInvisibleAttributes(\n          dzItem,\n          {\n            schema: compSchema,\n            initialValues: componentInitialValue,\n            components,\n          },\n          [...path, `${attrName}[${dzItem.__temp_key__}]`],\n          removedAttributes\n        ).data;\n\n        // For newly created components, we want to be sure that the id is undefined (in case of reordering items)\n        const processedItem =\n          dzItem.id === undefined || dzItem.id === null\n            ? { __component: compUID, ...cleaned, id: undefined }\n            : { __component: compUID, ...cleaned };\n\n        return processedItem;\n      });\n\n      continue;\n    }\n\n    // ðŸŸ¡ Handle scalar/primitive\n    if (currentValue !== undefined) {\n      result[attrName] = currentValue;\n    } else if (initialValue !== undefined) {\n      result[attrName] = initialValue;\n    } else {\n      if (attrName === 'id' || attrName === 'documentId') {\n        // If the attribute is 'id', we don't want to set it to null, as it should not be removed.\n        continue;\n      }\n      result[attrName] = null;\n    }\n  }\n\n  return {\n    data: result,\n    removedAttributes,\n  };\n};\n\nexport {\n  removeProhibitedFields,\n  prepareRelations,\n  prepareTempKeys,\n  removeFieldsThatDontExistOnSchema,\n  transformDocument,\n  handleInvisibleAttributes,\n};\nexport type { AnyData };\n"],"names":["BLOCK_LIST_ATTRIBUTE_KEYS","traverseData","predicate","transform","schema","components","data","traverse","datum","attributes","Object","entries","reduce","acc","key","value","attribute","includes","undefined","type","repeatable","componentValue","map","componentData","component","dynamicZoneValue","__component","removeProhibitedFields","prohibitedFields","prepareRelations","connect","disconnect","prepareTempKeys","Array","isArray","length","keys","generateNKeysBetween","index","__temp_key__","removeFieldsThatDontExistOnSchema","schemaKeys","dataKeys","keysToRemove","filter","revisedData","DOCUMENT_META_FIELDS","structuredClone","removeNullValues","transformDocument","document","transformations","pipe","getItemInitialValue","initialValue","item","matchingInitialItem","find","initialItem","handleInvisibleAttributes","initialValues","path","removedAttributes","rulesEngine","createRulesEngine","result","attrName","attrDef","fullPath","join","condition","conditions","visible","isVisible","evaluate","push","userProvided","prototype","hasOwnProperty","call","currentValue","compSchema","componentInitialValue","dzItem","compUID","cleaned","processedItem","id"],"mappings":"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"}