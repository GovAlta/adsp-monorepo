{"version":3,"file":"history.mjs","sources":["../../../../server/src/history/services/history.ts"],"sourcesContent":["import type { Core, Data, Modules, Schema } from '@strapi/types';\nimport { errors, traverseEntity } from '@strapi/utils';\nimport { omit } from 'lodash/fp';\n\nimport { FIELDS_TO_IGNORE, HISTORY_VERSION_UID } from '../constants';\nimport type { HistoryVersions } from '../../../../shared/contracts';\nimport type {\n  CreateHistoryVersion,\n  HistoryVersionDataResponse,\n} from '../../../../shared/contracts/history-versions';\nimport { createServiceUtils } from './utils';\nimport { getService as getContentManagerService } from '../../utils';\n\n// Needed because the query engine doesn't return any types yet\ntype HistoryVersionQueryResult = Omit<HistoryVersionDataResponse, 'locale'> &\n  Pick<CreateHistoryVersion, 'locale'>;\n\nconst createHistoryService = ({ strapi }: { strapi: Core.Strapi }) => {\n  const query = strapi.db.query(HISTORY_VERSION_UID);\n  const serviceUtils = createServiceUtils({ strapi });\n\n  return {\n    async createVersion(historyVersionData: HistoryVersions.CreateHistoryVersion) {\n      await query.create({\n        data: {\n          ...historyVersionData,\n          createdAt: new Date(),\n          createdBy: strapi.requestContext.get()?.state?.user.id,\n        },\n      });\n    },\n\n    async findVersionsPage(params: HistoryVersions.GetHistoryVersions.Request): Promise<{\n      results: HistoryVersions.HistoryVersionDataResponse[];\n      pagination: HistoryVersions.Pagination;\n    }> {\n      const schema = strapi.getModel(params.query.contentType);\n      const isLocalizedContentType = serviceUtils.isLocalizedContentType(schema);\n      const defaultLocale = await serviceUtils.getDefaultLocale();\n\n      let locale = null;\n      if (isLocalizedContentType) {\n        locale = params.query.locale || defaultLocale;\n      }\n\n      const [{ results, pagination }, localeDictionary] = await Promise.all([\n        query.findPage({\n          ...params.query,\n          where: {\n            $and: [\n              { contentType: params.query.contentType },\n              ...(params.query.documentId ? [{ relatedDocumentId: params.query.documentId }] : []),\n              ...(locale ? [{ locale }] : []),\n            ],\n          },\n          populate: ['createdBy'],\n          orderBy: [{ createdAt: 'desc' }],\n        }),\n        serviceUtils.getLocaleDictionary(),\n      ]);\n\n      const populateEntry = async (entry: HistoryVersionQueryResult) => {\n        return traverseEntity(\n          async (options, utils) => {\n            if (!options.attribute) return;\n            if (!options.value) return;\n\n            const currentValue: any[] = Array.isArray(options.value)\n              ? options.value\n              : [options.value];\n\n            if (options.attribute.type === 'component') {\n              // Ids on components throw an error when restoring\n              utils.remove('id');\n            }\n\n            if (\n              options.attribute.type === 'relation' &&\n              // TODO: handle polymorphic relations\n              options.attribute.relation !== 'morphToOne' &&\n              options.attribute.relation !== 'morphToMany'\n            ) {\n              if (options.attribute.target === 'admin::user') {\n                const adminUsers = await Promise.all(\n                  currentValue.map((userToPopulate) => {\n                    if (userToPopulate == null) {\n                      return null;\n                    }\n\n                    return strapi.query('admin::user').findOne({\n                      where: {\n                        ...(userToPopulate.id ? { id: userToPopulate.id } : {}),\n                        ...(userToPopulate.documentId\n                          ? { documentId: userToPopulate.documentId }\n                          : {}),\n                      },\n                    });\n                  })\n                );\n\n                utils.set(options.key, adminUsers as any);\n              }\n\n              const permissionChecker = getContentManagerService('permission-checker').create({\n                userAbility: params.state.userAbility,\n                model: options.attribute.target,\n              });\n\n              const response = await serviceUtils.buildRelationReponse(\n                currentValue,\n                options.attribute as Schema.Attribute.RelationWithTarget\n              );\n              const sanitizedResults = await Promise.all(\n                response.results.map((media) => permissionChecker.sanitizeOutput(media))\n              );\n\n              utils.set(options.key, {\n                results: sanitizedResults,\n                meta: response.meta,\n              });\n            }\n\n            if (options.attribute.type === 'media') {\n              const permissionChecker = getContentManagerService('permission-checker').create({\n                userAbility: params.state.userAbility,\n                model: 'plugin::upload.file',\n              });\n\n              const response = await serviceUtils.buildMediaResponse(currentValue);\n              const sanitizedResults = await Promise.all(\n                response.results.map((media) => permissionChecker.sanitizeOutput(media))\n              );\n\n              utils.set(options.key, {\n                results: sanitizedResults,\n                meta: response.meta,\n              });\n            }\n          },\n          {\n            schema,\n            getModel: strapi.getModel.bind(strapi),\n          },\n          entry.data\n        );\n      };\n\n      const formattedResults: any[] = await Promise.all(\n        (results as HistoryVersionQueryResult[]).map(async (result) => {\n          return {\n            ...result,\n            data: await populateEntry(result),\n            meta: {\n              unknownAttributes: serviceUtils.getSchemaAttributesDiff(\n                result.schema,\n                strapi.getModel(params.query.contentType).attributes\n              ),\n            },\n            locale: result.locale ? localeDictionary[result.locale] : null,\n          };\n        })\n      );\n\n      return {\n        results: formattedResults,\n        pagination,\n      };\n    },\n\n    async restoreVersion(versionId: Data.ID) {\n      const version = await query.findOne({ where: { id: versionId } });\n      const contentTypeSchemaAttributes = strapi.getModel(version.contentType).attributes;\n      const schemaDiff = serviceUtils.getSchemaAttributesDiff(\n        version.schema,\n        contentTypeSchemaAttributes\n      );\n\n      // Set all added attribute values to null\n      const dataWithoutAddedAttributes = Object.keys(schemaDiff.added).reduce(\n        (currentData, addedKey) => {\n          currentData[addedKey] = null;\n          return currentData;\n        },\n        // Clone to avoid mutating the original version data\n        structuredClone(version.data)\n      );\n\n      // Remove the schema attributes history should ignore\n      const schema = structuredClone(version.schema);\n      schema.attributes = omit(FIELDS_TO_IGNORE, contentTypeSchemaAttributes);\n\n      const dataWithoutMissingRelations = await traverseEntity(\n        async (options, utils) => {\n          if (!options.attribute) return;\n\n          if (options.attribute.type === 'component') {\n            // Ids on components throw an error when restoring\n            utils.remove('id');\n\n            if (options.attribute.repeatable && options.value === null) {\n              // Repeatable Components should always be an array\n              utils.set(options.key, [] as any);\n            }\n          }\n\n          if (options.attribute.type === 'dynamiczone') {\n            if (options.value === null) {\n              // Dynamic zones should always be an array\n              utils.set(options.key, [] as any);\n            }\n          }\n\n          if (\n            options.attribute.type === 'relation' &&\n            // TODO: handle polymorphic relations\n            options.attribute.relation !== 'morphToOne' &&\n            options.attribute.relation !== 'morphToMany'\n          ) {\n            if (!options.value) return;\n\n            const data = await serviceUtils.getRelationRestoreValue(\n              options.value as Modules.Documents.AnyDocument,\n              options.attribute as Schema.Attribute.RelationWithTarget\n            );\n\n            utils.set(options.key, data as Modules.Documents.AnyDocument);\n          }\n\n          if (options.attribute.type === 'media') {\n            if (!options.value) return;\n\n            const data = await serviceUtils.getMediaRestoreValue(\n              options.value as Modules.Documents.AnyDocument\n            );\n\n            utils.set(options.key, data);\n          }\n        },\n        {\n          schema,\n          getModel: strapi.getModel.bind(strapi),\n        },\n        dataWithoutAddedAttributes\n      );\n\n      const data = omit(['id', ...Object.keys(schemaDiff.removed)], dataWithoutMissingRelations);\n      const restoredDocument = await strapi.documents(version.contentType).update({\n        documentId: version.relatedDocumentId,\n        locale: version.locale,\n        data,\n      });\n\n      if (!restoredDocument) {\n        throw new errors.ApplicationError('Failed to restore version');\n      }\n\n      return restoredDocument;\n    },\n  };\n};\n\nexport { createHistoryService };\n"],"names":["createHistoryService","strapi","query","db","HISTORY_VERSION_UID","serviceUtils","createServiceUtils","createVersion","historyVersionData","create","data","createdAt","Date","createdBy","requestContext","get","state","user","id","findVersionsPage","params","schema","getModel","contentType","isLocalizedContentType","defaultLocale","getDefaultLocale","locale","results","pagination","localeDictionary","Promise","all","findPage","where","$and","documentId","relatedDocumentId","populate","orderBy","getLocaleDictionary","populateEntry","entry","traverseEntity","options","utils","attribute","value","currentValue","Array","isArray","type","remove","relation","target","adminUsers","map","userToPopulate","findOne","set","key","permissionChecker","getContentManagerService","userAbility","model","response","buildRelationReponse","sanitizedResults","media","sanitizeOutput","meta","buildMediaResponse","bind","formattedResults","result","unknownAttributes","getSchemaAttributesDiff","attributes","restoreVersion","versionId","version","contentTypeSchemaAttributes","schemaDiff","dataWithoutAddedAttributes","Object","keys","added","reduce","currentData","addedKey","structuredClone","omit","FIELDS_TO_IGNORE","dataWithoutMissingRelations","repeatable","getRelationRestoreValue","getMediaRestoreValue","removed","restoredDocument","documents","update","errors","ApplicationError"],"mappings":";;;;;;AAiBA,MAAMA,oBAAuB,GAAA,CAAC,EAAEC,MAAM,EAA2B,GAAA;AAC/D,IAAA,MAAMC,KAAQD,GAAAA,MAAAA,CAAOE,EAAE,CAACD,KAAK,CAACE,mBAAAA,CAAAA;AAC9B,IAAA,MAAMC,eAAeC,kBAAmB,CAAA;AAAEL,QAAAA;AAAO,KAAA,CAAA;IAEjD,OAAO;AACL,QAAA,MAAMM,eAAcC,kBAAwD,EAAA;YAC1E,MAAMN,KAAAA,CAAMO,MAAM,CAAC;gBACjBC,IAAM,EAAA;AACJ,oBAAA,GAAGF,kBAAkB;AACrBG,oBAAAA,SAAAA,EAAW,IAAIC,IAAAA,EAAAA;AACfC,oBAAAA,SAAAA,EAAWZ,OAAOa,cAAc,CAACC,GAAG,EAAA,EAAIC,OAAOC,IAAKC,CAAAA;AACtD;AACF,aAAA,CAAA;AACF,SAAA;AAEA,QAAA,MAAMC,kBAAiBC,MAAkD,EAAA;AAIvE,YAAA,MAAMC,SAASpB,MAAOqB,CAAAA,QAAQ,CAACF,MAAOlB,CAAAA,KAAK,CAACqB,WAAW,CAAA;YACvD,MAAMC,sBAAAA,GAAyBnB,YAAamB,CAAAA,sBAAsB,CAACH,MAAAA,CAAAA;YACnE,MAAMI,aAAAA,GAAgB,MAAMpB,YAAAA,CAAaqB,gBAAgB,EAAA;AAEzD,YAAA,IAAIC,MAAS,GAAA,IAAA;AACb,YAAA,IAAIH,sBAAwB,EAAA;AAC1BG,gBAAAA,MAAAA,GAASP,MAAOlB,CAAAA,KAAK,CAACyB,MAAM,IAAIF,aAAAA;AAClC;AAEA,YAAA,MAAM,CAAC,EAAEG,OAAO,EAAEC,UAAU,EAAE,EAAEC,gBAAAA,CAAiB,GAAG,MAAMC,OAAQC,CAAAA,GAAG,CAAC;AACpE9B,gBAAAA,KAAAA,CAAM+B,QAAQ,CAAC;AACb,oBAAA,GAAGb,OAAOlB,KAAK;oBACfgC,KAAO,EAAA;wBACLC,IAAM,EAAA;AACJ,4BAAA;gCAAEZ,WAAaH,EAAAA,MAAAA,CAAOlB,KAAK,CAACqB;AAAY,6BAAA;+BACpCH,MAAOlB,CAAAA,KAAK,CAACkC,UAAU,GAAG;AAAC,gCAAA;oCAAEC,iBAAmBjB,EAAAA,MAAAA,CAAOlB,KAAK,CAACkC;AAAW;AAAE,6BAAA,GAAG,EAAE;+BAC/ET,MAAS,GAAA;AAAC,gCAAA;AAAEA,oCAAAA;AAAO;AAAE,6BAAA,GAAG;AAC7B;AACH,qBAAA;oBACAW,QAAU,EAAA;AAAC,wBAAA;AAAY,qBAAA;oBACvBC,OAAS,EAAA;AAAC,wBAAA;4BAAE5B,SAAW,EAAA;AAAO;AAAE;AAClC,iBAAA,CAAA;AACAN,gBAAAA,YAAAA,CAAamC,mBAAmB;AACjC,aAAA,CAAA;AAED,YAAA,MAAMC,gBAAgB,OAAOC,KAAAA,GAAAA;gBAC3B,OAAOC,cAAAA,CACL,OAAOC,OAASC,EAAAA,KAAAA,GAAAA;oBACd,IAAI,CAACD,OAAQE,CAAAA,SAAS,EAAE;oBACxB,IAAI,CAACF,OAAQG,CAAAA,KAAK,EAAE;oBAEpB,MAAMC,YAAAA,GAAsBC,MAAMC,OAAO,CAACN,QAAQG,KAAK,CAAA,GACnDH,OAAQG,CAAAA,KAAK,GACb;AAACH,wBAAAA,OAAAA,CAAQG;AAAM,qBAAA;AAEnB,oBAAA,IAAIH,OAAQE,CAAAA,SAAS,CAACK,IAAI,KAAK,WAAa,EAAA;;AAE1CN,wBAAAA,KAAAA,CAAMO,MAAM,CAAC,IAAA,CAAA;AACf;AAEA,oBAAA,IACER,QAAQE,SAAS,CAACK,IAAI,KAAK;oBAE3BP,OAAQE,CAAAA,SAAS,CAACO,QAAQ,KAAK,YAAA,IAC/BT,QAAQE,SAAS,CAACO,QAAQ,KAAK,aAC/B,EAAA;AACA,wBAAA,IAAIT,OAAQE,CAAAA,SAAS,CAACQ,MAAM,KAAK,aAAe,EAAA;4BAC9C,MAAMC,UAAAA,GAAa,MAAMxB,OAAQC,CAAAA,GAAG,CAClCgB,YAAaQ,CAAAA,GAAG,CAAC,CAACC,cAAAA,GAAAA;AAChB,gCAAA,IAAIA,kBAAkB,IAAM,EAAA;oCAC1B,OAAO,IAAA;AACT;AAEA,gCAAA,OAAOxD,MAAOC,CAAAA,KAAK,CAAC,aAAA,CAAA,CAAewD,OAAO,CAAC;oCACzCxB,KAAO,EAAA;wCACL,GAAIuB,cAAAA,CAAevC,EAAE,GAAG;AAAEA,4CAAAA,EAAAA,EAAIuC,eAAevC;AAAG,yCAAA,GAAI,EAAE;wCACtD,GAAIuC,cAAAA,CAAerB,UAAU,GACzB;AAAEA,4CAAAA,UAAAA,EAAYqB,eAAerB;AAAW,yCAAA,GACxC;AACN;AACF,iCAAA,CAAA;AACF,6BAAA,CAAA,CAAA;AAGFS,4BAAAA,KAAAA,CAAMc,GAAG,CAACf,OAAQgB,CAAAA,GAAG,EAAEL,UAAAA,CAAAA;AACzB;AAEA,wBAAA,MAAMM,iBAAoBC,GAAAA,UAAAA,CAAyB,oBAAsBrD,CAAAA,CAAAA,MAAM,CAAC;4BAC9EsD,WAAa3C,EAAAA,MAAAA,CAAOJ,KAAK,CAAC+C,WAAW;4BACrCC,KAAOpB,EAAAA,OAAAA,CAAQE,SAAS,CAACQ;AAC3B,yBAAA,CAAA;AAEA,wBAAA,MAAMW,WAAW,MAAM5D,YAAAA,CAAa6D,oBAAoB,CACtDlB,YAAAA,EACAJ,QAAQE,SAAS,CAAA;AAEnB,wBAAA,MAAMqB,gBAAmB,GAAA,MAAMpC,OAAQC,CAAAA,GAAG,CACxCiC,QAASrC,CAAAA,OAAO,CAAC4B,GAAG,CAAC,CAACY,KAAUP,GAAAA,iBAAAA,CAAkBQ,cAAc,CAACD,KAAAA,CAAAA,CAAAA,CAAAA;AAGnEvB,wBAAAA,KAAAA,CAAMc,GAAG,CAACf,OAAQgB,CAAAA,GAAG,EAAE;4BACrBhC,OAASuC,EAAAA,gBAAAA;AACTG,4BAAAA,IAAAA,EAAML,SAASK;AACjB,yBAAA,CAAA;AACF;AAEA,oBAAA,IAAI1B,OAAQE,CAAAA,SAAS,CAACK,IAAI,KAAK,OAAS,EAAA;AACtC,wBAAA,MAAMU,iBAAoBC,GAAAA,UAAAA,CAAyB,oBAAsBrD,CAAAA,CAAAA,MAAM,CAAC;4BAC9EsD,WAAa3C,EAAAA,MAAAA,CAAOJ,KAAK,CAAC+C,WAAW;4BACrCC,KAAO,EAAA;AACT,yBAAA,CAAA;AAEA,wBAAA,MAAMC,QAAW,GAAA,MAAM5D,YAAakE,CAAAA,kBAAkB,CAACvB,YAAAA,CAAAA;AACvD,wBAAA,MAAMmB,gBAAmB,GAAA,MAAMpC,OAAQC,CAAAA,GAAG,CACxCiC,QAASrC,CAAAA,OAAO,CAAC4B,GAAG,CAAC,CAACY,KAAUP,GAAAA,iBAAAA,CAAkBQ,cAAc,CAACD,KAAAA,CAAAA,CAAAA,CAAAA;AAGnEvB,wBAAAA,KAAAA,CAAMc,GAAG,CAACf,OAAQgB,CAAAA,GAAG,EAAE;4BACrBhC,OAASuC,EAAAA,gBAAAA;AACTG,4BAAAA,IAAAA,EAAML,SAASK;AACjB,yBAAA,CAAA;AACF;iBAEF,EAAA;AACEjD,oBAAAA,MAAAA;AACAC,oBAAAA,QAAAA,EAAUrB,MAAOqB,CAAAA,QAAQ,CAACkD,IAAI,CAACvE,MAAAA;AACjC,iBAAA,EACAyC,MAAMhC,IAAI,CAAA;AAEd,aAAA;YAEA,MAAM+D,gBAAAA,GAA0B,MAAM1C,OAAQC,CAAAA,GAAG,CAC/C,OAACJ,CAAwC4B,GAAG,CAAC,OAAOkB,MAAAA,GAAAA;gBAClD,OAAO;AACL,oBAAA,GAAGA,MAAM;AACThE,oBAAAA,IAAAA,EAAM,MAAM+B,aAAciC,CAAAA,MAAAA,CAAAA;oBAC1BJ,IAAM,EAAA;AACJK,wBAAAA,iBAAAA,EAAmBtE,YAAauE,CAAAA,uBAAuB,CACrDF,MAAAA,CAAOrD,MAAM,EACbpB,MAAAA,CAAOqB,QAAQ,CAACF,MAAOlB,CAAAA,KAAK,CAACqB,WAAW,EAAEsD,UAAU;AAExD,qBAAA;oBACAlD,MAAQ+C,EAAAA,MAAAA,CAAO/C,MAAM,GAAGG,gBAAgB,CAAC4C,MAAO/C,CAAAA,MAAM,CAAC,GAAG;AAC5D,iBAAA;AACF,aAAA,CAAA,CAAA;YAGF,OAAO;gBACLC,OAAS6C,EAAAA,gBAAAA;AACT5C,gBAAAA;AACF,aAAA;AACF,SAAA;AAEA,QAAA,MAAMiD,gBAAeC,SAAkB,EAAA;AACrC,YAAA,MAAMC,OAAU,GAAA,MAAM9E,KAAMwD,CAAAA,OAAO,CAAC;gBAAExB,KAAO,EAAA;oBAAEhB,EAAI6D,EAAAA;AAAU;AAAE,aAAA,CAAA;AAC/D,YAAA,MAAME,8BAA8BhF,MAAOqB,CAAAA,QAAQ,CAAC0D,OAAQzD,CAAAA,WAAW,EAAEsD,UAAU;AACnF,YAAA,MAAMK,aAAa7E,YAAauE,CAAAA,uBAAuB,CACrDI,OAAAA,CAAQ3D,MAAM,EACd4D,2BAAAA,CAAAA;;YAIF,MAAME,0BAAAA,GAA6BC,MAAOC,CAAAA,IAAI,CAACH,UAAAA,CAAWI,KAAK,CAAEC,CAAAA,MAAM,CACrE,CAACC,WAAaC,EAAAA,QAAAA,GAAAA;gBACZD,WAAW,CAACC,SAAS,GAAG,IAAA;gBACxB,OAAOD,WAAAA;AACT,aAAA;AAEAE,YAAAA,eAAAA,CAAgBV,QAAQtE,IAAI,CAAA,CAAA;;YAI9B,MAAMW,MAAAA,GAASqE,eAAgBV,CAAAA,OAAAA,CAAQ3D,MAAM,CAAA;YAC7CA,MAAOwD,CAAAA,UAAU,GAAGc,IAAAA,CAAKC,gBAAkBX,EAAAA,2BAAAA,CAAAA;AAE3C,YAAA,MAAMY,2BAA8B,GAAA,MAAMlD,cACxC,CAAA,OAAOC,OAASC,EAAAA,KAAAA,GAAAA;gBACd,IAAI,CAACD,OAAQE,CAAAA,SAAS,EAAE;AAExB,gBAAA,IAAIF,OAAQE,CAAAA,SAAS,CAACK,IAAI,KAAK,WAAa,EAAA;;AAE1CN,oBAAAA,KAAAA,CAAMO,MAAM,CAAC,IAAA,CAAA;oBAEb,IAAIR,OAAAA,CAAQE,SAAS,CAACgD,UAAU,IAAIlD,OAAQG,CAAAA,KAAK,KAAK,IAAM,EAAA;;AAE1DF,wBAAAA,KAAAA,CAAMc,GAAG,CAACf,OAAQgB,CAAAA,GAAG,EAAE,EAAE,CAAA;AAC3B;AACF;AAEA,gBAAA,IAAIhB,OAAQE,CAAAA,SAAS,CAACK,IAAI,KAAK,aAAe,EAAA;oBAC5C,IAAIP,OAAAA,CAAQG,KAAK,KAAK,IAAM,EAAA;;AAE1BF,wBAAAA,KAAAA,CAAMc,GAAG,CAACf,OAAQgB,CAAAA,GAAG,EAAE,EAAE,CAAA;AAC3B;AACF;AAEA,gBAAA,IACEhB,QAAQE,SAAS,CAACK,IAAI,KAAK;gBAE3BP,OAAQE,CAAAA,SAAS,CAACO,QAAQ,KAAK,YAAA,IAC/BT,QAAQE,SAAS,CAACO,QAAQ,KAAK,aAC/B,EAAA;oBACA,IAAI,CAACT,OAAQG,CAAAA,KAAK,EAAE;oBAEpB,MAAMrC,IAAAA,GAAO,MAAML,YAAa0F,CAAAA,uBAAuB,CACrDnD,OAAQG,CAAAA,KAAK,EACbH,OAAAA,CAAQE,SAAS,CAAA;AAGnBD,oBAAAA,KAAAA,CAAMc,GAAG,CAACf,OAAQgB,CAAAA,GAAG,EAAElD,IAAAA,CAAAA;AACzB;AAEA,gBAAA,IAAIkC,OAAQE,CAAAA,SAAS,CAACK,IAAI,KAAK,OAAS,EAAA;oBACtC,IAAI,CAACP,OAAQG,CAAAA,KAAK,EAAE;AAEpB,oBAAA,MAAMrC,OAAO,MAAML,YAAAA,CAAa2F,oBAAoB,CAClDpD,QAAQG,KAAK,CAAA;AAGfF,oBAAAA,KAAAA,CAAMc,GAAG,CAACf,OAAQgB,CAAAA,GAAG,EAAElD,IAAAA,CAAAA;AACzB;aAEF,EAAA;AACEW,gBAAAA,MAAAA;AACAC,gBAAAA,QAAAA,EAAUrB,MAAOqB,CAAAA,QAAQ,CAACkD,IAAI,CAACvE,MAAAA;aAEjCkF,EAAAA,0BAAAA,CAAAA;AAGF,YAAA,MAAMzE,OAAOiF,IAAK,CAAA;AAAC,gBAAA,IAAA;mBAASP,MAAOC,CAAAA,IAAI,CAACH,UAAAA,CAAWe,OAAO;aAAE,EAAEJ,2BAAAA,CAAAA;YAC9D,MAAMK,gBAAAA,GAAmB,MAAMjG,MAAOkG,CAAAA,SAAS,CAACnB,OAAQzD,CAAAA,WAAW,CAAE6E,CAAAA,MAAM,CAAC;AAC1EhE,gBAAAA,UAAAA,EAAY4C,QAAQ3C,iBAAiB;AACrCV,gBAAAA,MAAAA,EAAQqD,QAAQrD,MAAM;AACtBjB,gBAAAA;AACF,aAAA,CAAA;AAEA,YAAA,IAAI,CAACwF,gBAAkB,EAAA;gBACrB,MAAM,IAAIG,MAAOC,CAAAA,gBAAgB,CAAC,2BAAA,CAAA;AACpC;YAEA,OAAOJ,gBAAAA;AACT;AACF,KAAA;AACF;;;;"}