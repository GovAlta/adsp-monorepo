{"version":3,"file":"convert-query-params.mjs","sources":["../src/convert-query-params.ts"],"sourcesContent":["/* eslint-disable max-classes-per-file */\n\n/**\n * Converts the standard Strapi REST query params to a more usable format for querying\n * You can read more here: https://docs.strapi.io/developer-docs/latest/developer-resources/database-apis-reference/rest-api.html#filters\n */\n\nimport _ from 'lodash';\nimport {\n  cloneDeep,\n  get,\n  isArray,\n  isEmpty,\n  isInteger,\n  isNil,\n  isObject,\n  isString,\n  toNumber,\n} from 'lodash/fp';\nimport {\n  constants,\n  hasDraftAndPublish,\n  isDynamicZoneAttribute,\n  isMorphToRelationalAttribute,\n} from './content-types';\nimport { PaginationError } from './errors';\nimport { isOperator } from './operators';\n\nimport parseType from './parse-type';\nimport { Model } from './types';\n\nconst { ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, PUBLISHED_AT_ATTRIBUTE } = constants;\n\ntype SortOrder = 'asc' | 'desc';\n\nexport interface SortMap {\n  [key: string]: SortOrder | SortMap;\n}\n\nexport interface SortParamsObject {\n  [key: string]: SortOrder | SortParamsObject;\n}\n\ntype SortParams = string | string[] | SortParamsObject | SortParamsObject[];\ntype FieldsParams = string | string[];\n\ntype FiltersParams = unknown;\n\nexport interface PopulateAttributesParams {\n  [key: string]: boolean | PopulateObjectParams;\n}\n\nexport interface PopulateObjectParams {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: string | string[] | PopulateAttributesParams;\n  on?: PopulateAttributesParams;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number | string;\n  start?: number | string;\n  page?: number | string;\n  pageSize?: number | string;\n}\n\ntype PopulateParams = string | string[] | PopulateAttributesParams;\n\nexport interface Params {\n  sort?: SortParams;\n  fields?: FieldsParams;\n  filters?: FiltersParams;\n  populate?: PopulateParams;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number | string;\n  start?: number | string;\n  page?: number | string;\n  pageSize?: number | string;\n  status?: 'draft' | 'published';\n}\n\ntype FiltersQuery = (options: { meta: Model }) => WhereQuery | undefined;\ntype OrderByQuery = SortMap | SortMap[];\ntype SelectQuery = string | string[];\n\nexport interface WhereQuery {\n  [key: string]: any;\n}\n\ntype PopulateQuery =\n  | boolean\n  | string[]\n  | {\n      [key: string]: PopulateQuery;\n    };\n\nexport interface Query {\n  orderBy?: OrderByQuery;\n  select?: SelectQuery;\n  where?: WhereQuery;\n  // NOTE: those are internal DB filters do not modify\n  filters?: FiltersQuery;\n  populate?: PopulateQuery;\n  count?: boolean;\n  ordering?: unknown;\n  _q?: string;\n  limit?: number;\n  offset?: number;\n  page?: number;\n  pageSize?: number;\n}\n\nclass InvalidOrderError extends Error {\n  constructor() {\n    super();\n    this.message = 'Invalid order. order can only be one of asc|desc|ASC|DESC';\n  }\n}\n\nclass InvalidSortError extends Error {\n  constructor() {\n    super();\n    this.message =\n      'Invalid sort parameter. Expected a string, an array of strings, a sort object or an array of sort objects';\n  }\n}\n\nfunction validateOrder(order: string): asserts order is SortOrder {\n  if (!isString(order) || !['asc', 'desc'].includes(order.toLocaleLowerCase())) {\n    throw new InvalidOrderError();\n  }\n}\n\nconst convertCountQueryParams = (countQuery: unknown): boolean => {\n  return parseType({ type: 'boolean', value: countQuery });\n};\n\nconst convertOrderingQueryParams = (ordering: unknown) => {\n  return ordering;\n};\n\nconst isPlainObject = (value: unknown): value is Record<string, unknown> => _.isPlainObject(value);\nconst isStringArray = (value: unknown): value is string[] =>\n  isArray(value) && value.every(isString);\n\ninterface TransformerOptions {\n  getModel: (uid: string) => Model | undefined;\n}\n\nconst createTransformer = ({ getModel }: TransformerOptions) => {\n  /**\n   * Sort query parser\n   */\n  const convertSortQueryParams = (sortQuery: SortParams): OrderByQuery => {\n    if (typeof sortQuery === 'string') {\n      return convertStringSortQueryParam(sortQuery);\n    }\n\n    if (isStringArray(sortQuery)) {\n      return sortQuery.flatMap((sortValue: string) => convertStringSortQueryParam(sortValue));\n    }\n\n    if (Array.isArray(sortQuery)) {\n      return sortQuery.map((sortValue) => convertNestedSortQueryParam(sortValue));\n    }\n\n    if (isPlainObject(sortQuery)) {\n      return convertNestedSortQueryParam(sortQuery);\n    }\n\n    throw new InvalidSortError();\n  };\n\n  const convertStringSortQueryParam = (sortQuery: string): SortMap[] => {\n    return sortQuery.split(',').map((value) => convertSingleSortQueryParam(value));\n  };\n\n  const convertSingleSortQueryParam = (sortQuery: string): SortMap => {\n    if (!sortQuery) {\n      return {};\n    }\n\n    if (!isString(sortQuery)) {\n      throw new Error('Invalid sort query');\n    }\n\n    // split field and order param with default order to ascending\n    const [field, order = 'asc'] = sortQuery.split(':');\n\n    if (field.length === 0) {\n      throw new Error('Field cannot be empty');\n    }\n\n    validateOrder(order);\n\n    // TODO: field should be a valid path on an object model\n\n    return _.set({}, field, order);\n  };\n\n  const convertNestedSortQueryParam = (sortQuery: SortParamsObject): SortMap => {\n    const transformedSort: SortMap = {};\n    for (const field of Object.keys(sortQuery)) {\n      const order = sortQuery[field];\n\n      // this is a deep sort\n      if (isPlainObject(order)) {\n        transformedSort[field] = convertNestedSortQueryParam(order);\n      } else if (typeof order === 'string') {\n        validateOrder(order);\n        transformedSort[field] = order;\n      } else {\n        throw Error(`Invalid sort type expected object or string got ${typeof order}`);\n      }\n    }\n\n    return transformedSort;\n  };\n\n  /**\n   * Start query parser\n   */\n  const convertStartQueryParams = (startQuery: unknown): number => {\n    const startAsANumber = toNumber(startQuery);\n\n    if (!_.isInteger(startAsANumber) || startAsANumber < 0) {\n      throw new Error(`convertStartQueryParams expected a positive integer got ${startAsANumber}`);\n    }\n\n    return startAsANumber;\n  };\n\n  /**\n   * Limit query parser\n   */\n  const convertLimitQueryParams = (limitQuery: unknown): number | undefined => {\n    const limitAsANumber = toNumber(limitQuery);\n\n    if (!_.isInteger(limitAsANumber) || (limitAsANumber !== -1 && limitAsANumber < 0)) {\n      throw new Error(`convertLimitQueryParams expected a positive integer got ${limitAsANumber}`);\n    }\n\n    if (limitAsANumber === -1) {\n      return undefined;\n    }\n\n    return limitAsANumber;\n  };\n\n  const convertPageQueryParams = (page: unknown): number => {\n    const pageVal = toNumber(page);\n\n    if (!isInteger(pageVal) || pageVal <= 0) {\n      throw new PaginationError(\n        `Invalid 'page' parameter. Expected an integer > 0, received: ${page}`\n      );\n    }\n\n    return pageVal;\n  };\n\n  const convertPageSizeQueryParams = (pageSize: unknown, page: unknown): number => {\n    const pageSizeVal = toNumber(pageSize);\n\n    if (!isInteger(pageSizeVal) || pageSizeVal <= 0) {\n      throw new PaginationError(\n        `Invalid 'pageSize' parameter. Expected an integer > 0, received: ${page}`\n      );\n    }\n\n    return pageSizeVal;\n  };\n\n  const validatePaginationParams = (\n    page: unknown,\n    pageSize: unknown,\n    start: unknown,\n    limit: unknown\n  ) => {\n    const isPagePagination = !isNil(page) || !isNil(pageSize);\n    const isOffsetPagination = !isNil(start) || !isNil(limit);\n\n    if (isPagePagination && isOffsetPagination) {\n      throw new PaginationError(\n        'Invalid pagination attributes. The page parameters are incorrect and must be in the pagination object'\n      );\n    }\n  };\n\n  class InvalidPopulateError extends Error {\n    constructor() {\n      super();\n      this.message =\n        'Invalid populate parameter. Expected a string, an array of strings, a populate object';\n    }\n  }\n\n  // NOTE: we could support foo.* or foo.bar.* etc later on\n  const convertPopulateQueryParams = (\n    populate: PopulateParams,\n    schema?: Model,\n    depth = 0\n  ): PopulateQuery => {\n    if (depth === 0 && populate === '*') {\n      return true;\n    }\n\n    if (typeof populate === 'string') {\n      return populate.split(',').map((value) => _.trim(value));\n    }\n\n    if (Array.isArray(populate)) {\n      // map convert\n      return _.uniq(\n        populate.flatMap((value) => {\n          if (typeof value !== 'string') {\n            throw new InvalidPopulateError();\n          }\n\n          return value.split(',').map((value) => _.trim(value));\n        })\n      );\n    }\n\n    if (_.isPlainObject(populate)) {\n      return convertPopulateObject(populate, schema);\n    }\n\n    throw new InvalidPopulateError();\n  };\n\n  const hasPopulateFragmentDefined = (\n    populate: PopulateObjectParams\n  ): populate is PopulateObjectParams & Required<Pick<PopulateObjectParams, 'on'>> => {\n    return typeof populate === 'object' && 'on' in populate && !isNil(populate.on);\n  };\n\n  const hasCountDefined = (\n    populate: PopulateObjectParams\n  ): populate is PopulateObjectParams & { count: boolean } => {\n    return (\n      typeof populate === 'object' && 'count' in populate && typeof populate.count === 'boolean'\n    );\n  };\n\n  const convertPopulateObject = (populate: PopulateAttributesParams, schema?: Model) => {\n    if (!schema) {\n      return {};\n    }\n\n    const { attributes } = schema;\n    return Object.entries(populate).reduce((acc, [key, subPopulate]) => {\n      // Try converting strings to regular booleans if possible\n      if (_.isString(subPopulate)) {\n        try {\n          const subPopulateAsBoolean = parseType({ type: 'boolean', value: subPopulate });\n          // Only true is accepted as a boolean populate value\n          return subPopulateAsBoolean ? { ...acc, [key]: true } : acc;\n        } catch {\n          // ignore\n        }\n      }\n\n      if (_.isBoolean(subPopulate)) {\n        // Only true is accepted as a boolean populate value\n        return subPopulate === true ? { ...acc, [key]: true } : acc;\n      }\n\n      const attribute = attributes[key];\n\n      if (!attribute) {\n        return acc;\n      }\n\n      // Allow adding an 'on' strategy to populate queries for morphTo relations and dynamic zones\n      const isMorphLikeRelationalAttribute =\n        isDynamicZoneAttribute(attribute) || isMorphToRelationalAttribute(attribute);\n\n      if (isMorphLikeRelationalAttribute) {\n        const hasInvalidProperties = Object.keys(subPopulate).some(\n          (key) => !['populate', 'on', 'count'].includes(key)\n        );\n\n        if (hasInvalidProperties) {\n          throw new Error(\n            `Invalid nested populate for ${schema.info?.singularName}.${key} (${schema.uid}). Expected a fragment (\"on\") or \"count\" but found ${JSON.stringify(subPopulate)}`\n          );\n        }\n\n        /**\n         * Validate nested population queries in the context of a polymorphic attribute (dynamic zone, morph relation).\n         *\n         * If 'populate' exists in subPopulate, its value should be constrained to a wildcard ('*').\n         */\n        if ('populate' in subPopulate && subPopulate.populate !== '*') {\n          throw new Error(\n            `Invalid nested population query detected. When using 'populate' within polymorphic structures, ` +\n              `its value must be '*' to indicate all second level links. Specific field targeting is not supported here. ` +\n              `Consider using the fragment API for more granular population control.`\n          );\n        }\n\n        // TODO: Remove the possibility to have multiple properties at the same time (on/count/populate)\n        const newSubPopulate = {};\n\n        // case: { populate: '*' }\n        if ('populate' in subPopulate) {\n          Object.assign(newSubPopulate, { populate: true });\n        }\n\n        // case: { on: { <clauses> } }\n        if (hasPopulateFragmentDefined(subPopulate)) {\n          // If the fragment API is used, it applies the transformation to every\n          // sub-populate, then assign the result to the new sub-populate\n          Object.assign(newSubPopulate, {\n            on: Object.entries(subPopulate.on).reduce(\n              (acc, [type, typeSubPopulate]) => ({\n                ...acc,\n                [type]: convertNestedPopulate(typeSubPopulate, getModel(type)),\n              }),\n              {}\n            ),\n          });\n        }\n\n        // case: { count: true | false }\n        if (hasCountDefined(subPopulate)) {\n          Object.assign(newSubPopulate, { count: subPopulate.count });\n        }\n\n        return { ...acc, [key]: newSubPopulate };\n      }\n\n      // Edge case when trying to use the fragment ('on') on a non-morph like attribute\n      if (!isMorphLikeRelationalAttribute && hasPopulateFragmentDefined(subPopulate)) {\n        throw new Error(`Using fragments is not permitted to populate \"${key}\" in \"${schema.uid}\"`);\n      }\n\n      // NOTE: Retrieve the target schema UID.\n      // Only handles basic relations, medias and component since it's not possible\n      // to populate with options for a dynamic zone or a polymorphic relation\n      let targetSchemaUID;\n\n      if (attribute.type === 'relation') {\n        targetSchemaUID = attribute.target;\n      } else if (attribute.type === 'component') {\n        targetSchemaUID = attribute.component;\n      } else if (attribute.type === 'media') {\n        targetSchemaUID = 'plugin::upload.file';\n      } else {\n        return acc;\n      }\n\n      const targetSchema = getModel(targetSchemaUID!);\n\n      // ignore the sub-populate for the current key if there is no schema associated\n      if (!targetSchema) {\n        return acc;\n      }\n\n      const populateObject = convertNestedPopulate(subPopulate, targetSchema);\n\n      if (!populateObject) {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [key]: populateObject,\n      };\n    }, {});\n  };\n\n  const convertNestedPopulate = (subPopulate: boolean | PopulateObjectParams, schema?: Model) => {\n    if (_.isString(subPopulate)) {\n      return parseType({ type: 'boolean', value: subPopulate, forceCast: true });\n    }\n\n    if (_.isBoolean(subPopulate)) {\n      return subPopulate;\n    }\n\n    if (!isPlainObject(subPopulate)) {\n      throw new Error(`Invalid nested populate. Expected '*' or an object`);\n    }\n\n    const { sort, filters, fields, populate, count, ordering, page, pageSize, start, limit } =\n      subPopulate as PopulateObjectParams;\n\n    const query: Query = {};\n\n    if (sort) {\n      query.orderBy = convertSortQueryParams(sort);\n    }\n\n    if (filters) {\n      query.where = convertFiltersQueryParams(filters, schema);\n    }\n\n    if (fields) {\n      query.select = convertFieldsQueryParams(fields, schema);\n    }\n\n    if (populate) {\n      query.populate = convertPopulateQueryParams(populate, schema);\n    }\n\n    if (count) {\n      query.count = convertCountQueryParams(count);\n    }\n\n    if (ordering) {\n      query.ordering = convertOrderingQueryParams(ordering);\n    }\n\n    validatePaginationParams(page, pageSize, start, limit);\n\n    if (!isNil(page)) {\n      query.page = convertPageQueryParams(page);\n    }\n\n    if (!isNil(pageSize)) {\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\n    }\n\n    if (!isNil(start)) {\n      query.offset = convertStartQueryParams(start);\n    }\n\n    if (!isNil(limit)) {\n      query.limit = convertLimitQueryParams(limit);\n    }\n\n    return query;\n  };\n\n  // TODO: ensure field is valid in content types (will probably have to check strapi.contentTypes since it can be a string.path)\n  const convertFieldsQueryParams = (\n    fields: FieldsParams,\n    schema?: Model,\n    depth = 0\n  ): SelectQuery | undefined => {\n    if (depth === 0 && fields === '*') {\n      return undefined;\n    }\n\n    if (typeof fields === 'string') {\n      const fieldsValues = fields.split(',').map((value) => _.trim(value));\n\n      // NOTE: Only include the doc id if it's a content type\n      if (schema?.modelType === 'contentType') {\n        return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\n      }\n      return _.uniq([ID_ATTRIBUTE, ...fieldsValues]);\n    }\n\n    if (isStringArray(fields)) {\n      // map convert\n      const fieldsValues = fields\n        .flatMap((value) => convertFieldsQueryParams(value, schema, depth + 1))\n        .filter((v) => !isNil(v)) as string[];\n\n      // NOTE: Only include the doc id if it's a content type\n      if (schema?.modelType === 'contentType') {\n        return _.uniq([ID_ATTRIBUTE, DOC_ID_ATTRIBUTE, ...fieldsValues]);\n      }\n      return _.uniq([ID_ATTRIBUTE, ...fieldsValues]);\n    }\n\n    throw new Error('Invalid fields parameter. Expected a string or an array of strings');\n  };\n\n  const isValidSchemaAttribute = (key: string, schema?: Model) => {\n    if ([DOC_ID_ATTRIBUTE, ID_ATTRIBUTE].includes(key)) {\n      return true;\n    }\n\n    if (!schema) {\n      return false;\n    }\n\n    return Object.keys(schema.attributes).includes(key);\n  };\n\n  const convertFiltersQueryParams = (filters: FiltersParams, schema?: Model): WhereQuery => {\n    // Filters need to be either an array or an object\n    // Here we're only checking for 'object' type since typeof [] => object and typeof {} => object\n    if (!isObject(filters)) {\n      throw new Error('The filters parameter must be an object or an array');\n    }\n\n    // Don't mutate the original object\n    const filtersCopy = cloneDeep(filters);\n\n    return convertAndSanitizeFilters(filtersCopy, schema);\n  };\n\n  const convertAndSanitizeFilters = (filters: FiltersParams, schema?: Model): WhereQuery => {\n    if (Array.isArray(filters)) {\n      return (\n        filters\n          // Sanitize each filter\n          .map((filter) => convertAndSanitizeFilters(filter, schema))\n          // Filter out empty filters\n          .filter((filter) => !isPlainObject(filter) || !isEmpty(filter))\n      );\n    }\n\n    if (!isPlainObject(filters)) {\n      return filters as WhereQuery;\n    }\n\n    const removeOperator = (operator: string) => delete filters[operator];\n\n    // Here, `key` can either be an operator or an attribute name\n    for (const [key, value] of Object.entries(filters)) {\n      const attribute = get(key, schema?.attributes);\n      const validKey = isOperator(key) || isValidSchemaAttribute(key, schema);\n\n      if (!validKey) {\n        removeOperator(key);\n      }\n      // Handle attributes\n      else if (attribute) {\n        // Relations\n        if (attribute.type === 'relation') {\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.target!));\n        }\n\n        // Components\n        else if (attribute.type === 'component') {\n          filters[key] = convertAndSanitizeFilters(value, getModel(attribute.component));\n        }\n\n        // Media\n        else if (attribute.type === 'media') {\n          filters[key] = convertAndSanitizeFilters(value, getModel('plugin::upload.file'));\n        }\n\n        // Dynamic Zones\n        else if (attribute.type === 'dynamiczone') {\n          removeOperator(key);\n        }\n\n        // Password attributes\n        else if (attribute.type === 'password') {\n          // Always remove password attributes from filters object\n          removeOperator(key);\n        }\n\n        // Scalar attributes\n        else {\n          filters[key] = convertAndSanitizeFilters(value, schema);\n        }\n      }\n\n      // Handle operators\n      else if (['$null', '$notNull'].includes(key)) {\n        filters[key] = parseType({ type: 'boolean', value: filters[key], forceCast: true });\n      } else if (isObject(value)) {\n        filters[key] = convertAndSanitizeFilters(value, schema);\n      }\n\n      // Remove empty objects & arrays\n      if (isPlainObject(filters[key]) && isEmpty(filters[key])) {\n        removeOperator(key);\n      }\n    }\n\n    return filters;\n  };\n\n  const convertStatusParams = (status?: 'draft' | 'published', query: Query = {}) => {\n    // NOTE: this is the query layer filters not the document/entity service filters\n    query.filters = ({ meta }: { meta: Model }) => {\n      const contentType = getModel(meta.uid);\n\n      // Ignore if target model has disabled DP, as it doesn't make sense to filter by its status\n      if (!contentType || !hasDraftAndPublish(contentType)) {\n        return {};\n      }\n\n      return { [PUBLISHED_AT_ATTRIBUTE]: { $null: status === 'draft' } };\n    };\n  };\n\n  const transformQueryParams = (uid: string, params: Params): Query => {\n    // NOTE: can be a CT, a Compo or nothing in the case of polymorphism (DZ & morph relations)\n    const schema = getModel(uid);\n\n    const query: Query = {};\n\n    const { _q, sort, filters, fields, populate, page, pageSize, start, limit, status, ...rest } =\n      params;\n\n    if (!isNil(status)) {\n      convertStatusParams(status, query);\n    }\n\n    if (!isNil(_q)) {\n      query._q = _q;\n    }\n\n    if (!isNil(sort)) {\n      query.orderBy = convertSortQueryParams(sort);\n    }\n\n    if (!isNil(filters)) {\n      query.where = convertFiltersQueryParams(filters, schema);\n    }\n\n    if (!isNil(fields)) {\n      query.select = convertFieldsQueryParams(fields, schema);\n    }\n\n    if (!isNil(populate)) {\n      query.populate = convertPopulateQueryParams(populate, schema);\n    }\n\n    validatePaginationParams(page, pageSize, start, limit);\n\n    if (!isNil(page)) {\n      query.page = convertPageQueryParams(page);\n    }\n\n    if (!isNil(pageSize)) {\n      query.pageSize = convertPageSizeQueryParams(pageSize, page);\n    }\n\n    if (!isNil(start)) {\n      query.offset = convertStartQueryParams(start);\n    }\n\n    if (!isNil(limit)) {\n      query.limit = convertLimitQueryParams(limit);\n    }\n\n    return {\n      ...rest,\n      ...query,\n    };\n  };\n\n  return {\n    private_convertSortQueryParams: convertSortQueryParams,\n    private_convertStartQueryParams: convertStartQueryParams,\n    private_convertLimitQueryParams: convertLimitQueryParams,\n    private_convertPopulateQueryParams: convertPopulateQueryParams,\n    private_convertFiltersQueryParams: convertFiltersQueryParams,\n    private_convertFieldsQueryParams: convertFieldsQueryParams,\n    transformQueryParams,\n  };\n};\n\nexport { createTransformer };\n"],"names":["ID_ATTRIBUTE","DOC_ID_ATTRIBUTE","PUBLISHED_AT_ATTRIBUTE","constants","InvalidOrderError","Error","constructor","message","InvalidSortError","validateOrder","order","isString","includes","toLocaleLowerCase","convertCountQueryParams","countQuery","parseType","type","value","convertOrderingQueryParams","ordering","isPlainObject","_","isStringArray","isArray","every","createTransformer","getModel","convertSortQueryParams","sortQuery","convertStringSortQueryParam","flatMap","sortValue","Array","map","convertNestedSortQueryParam","split","convertSingleSortQueryParam","field","length","set","transformedSort","Object","keys","convertStartQueryParams","startQuery","startAsANumber","toNumber","isInteger","convertLimitQueryParams","limitQuery","limitAsANumber","undefined","convertPageQueryParams","page","pageVal","PaginationError","convertPageSizeQueryParams","pageSize","pageSizeVal","validatePaginationParams","start","limit","isPagePagination","isNil","isOffsetPagination","InvalidPopulateError","convertPopulateQueryParams","populate","schema","depth","trim","uniq","convertPopulateObject","hasPopulateFragmentDefined","on","hasCountDefined","count","attributes","entries","reduce","acc","key","subPopulate","subPopulateAsBoolean","isBoolean","attribute","isMorphLikeRelationalAttribute","isDynamicZoneAttribute","isMorphToRelationalAttribute","hasInvalidProperties","some","info","singularName","uid","JSON","stringify","newSubPopulate","assign","typeSubPopulate","convertNestedPopulate","targetSchemaUID","target","component","targetSchema","populateObject","forceCast","sort","filters","fields","query","orderBy","where","convertFiltersQueryParams","select","convertFieldsQueryParams","offset","fieldsValues","modelType","filter","v","isValidSchemaAttribute","isObject","filtersCopy","cloneDeep","convertAndSanitizeFilters","isEmpty","removeOperator","operator","get","validKey","isOperator","convertStatusParams","status","meta","contentType","hasDraftAndPublish","$null","transformQueryParams","params","_q","rest","private_convertSortQueryParams","private_convertStartQueryParams","private_convertLimitQueryParams","private_convertPopulateQueryParams","private_convertFiltersQueryParams","private_convertFieldsQueryParams"],"mappings":"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"}