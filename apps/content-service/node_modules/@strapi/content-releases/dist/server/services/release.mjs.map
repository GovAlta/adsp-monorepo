{"version":3,"file":"release.mjs","sources":["../../../server/src/services/release.ts"],"sourcesContent":["import { setCreatorFields, errors } from '@strapi/utils';\n\nimport type { Core, Struct, UID, Data } from '@strapi/types';\n\nimport { ALLOWED_WEBHOOK_EVENTS, RELEASE_ACTION_MODEL_UID, RELEASE_MODEL_UID } from '../constants';\nimport type {\n  GetReleases,\n  CreateRelease,\n  UpdateRelease,\n  PublishRelease,\n  GetRelease,\n  Release,\n  DeleteRelease,\n} from '../../../shared/contracts/releases';\nimport type { ReleaseAction } from '../../../shared/contracts/release-actions';\nimport type { UserInfo } from '../../../shared/types';\nimport { getService } from '../utils';\n\nconst createReleaseService = ({ strapi }: { strapi: Core.Strapi }) => {\n  const dispatchWebhook = (\n    event: string,\n    { isPublished, release, error }: { isPublished: boolean; release?: any; error?: unknown }\n  ) => {\n    strapi.eventHub.emit(event, {\n      isPublished,\n      error,\n      release,\n    });\n  };\n\n  /**\n   * Given a release id, it returns the actions formatted ready to be used to publish them.\n   * We split them by contentType and type (publish/unpublish) and extract only the documentIds and locales.\n   */\n  const getFormattedActions = async (releaseId: Release['id']) => {\n    const actions = (await strapi.db.query(RELEASE_ACTION_MODEL_UID).findMany({\n      where: {\n        release: {\n          id: releaseId,\n        },\n      },\n    })) as ReleaseAction[];\n\n    if (actions.length === 0) {\n      throw new errors.ValidationError('No entries to publish');\n    }\n\n    /**\n     * We separate publish and unpublish actions, grouping them by contentType and extracting only their documentIds and locales.\n     */\n    const formattedActions: {\n      [key: UID.ContentType]: {\n        publish: { documentId: ReleaseAction['entryDocumentId']; locale?: string }[];\n        unpublish: { documentId: ReleaseAction['entryDocumentId']; locale?: string }[];\n      };\n    } = {};\n\n    for (const action of actions) {\n      const contentTypeUid: UID.ContentType = action.contentType;\n\n      if (!formattedActions[contentTypeUid]) {\n        formattedActions[contentTypeUid] = {\n          publish: [],\n          unpublish: [],\n        };\n      }\n\n      formattedActions[contentTypeUid][action.type].push({\n        documentId: action.entryDocumentId,\n        locale: action.locale,\n      });\n    }\n\n    return formattedActions;\n  };\n\n  return {\n    async create(releaseData: CreateRelease.Request['body'], { user }: { user: UserInfo }) {\n      const releaseWithCreatorFields = await setCreatorFields({ user })(releaseData);\n\n      const {\n        validatePendingReleasesLimit,\n        validateUniqueNameForPendingRelease,\n        validateScheduledAtIsLaterThanNow,\n      } = getService('release-validation', { strapi });\n\n      await Promise.all([\n        validatePendingReleasesLimit(),\n        validateUniqueNameForPendingRelease(releaseWithCreatorFields.name),\n        validateScheduledAtIsLaterThanNow(releaseWithCreatorFields.scheduledAt),\n      ]);\n\n      const release = await strapi.db.query(RELEASE_MODEL_UID).create({\n        data: {\n          ...releaseWithCreatorFields,\n          status: 'empty',\n        },\n      });\n\n      if (releaseWithCreatorFields.scheduledAt) {\n        const schedulingService = getService('scheduling', { strapi });\n\n        await schedulingService.set(release.id, release.scheduledAt);\n      }\n\n      strapi.telemetry.send('didCreateContentRelease');\n\n      return release;\n    },\n\n    async findOne(id: GetRelease.Request['params']['id'], query = {}) {\n      const dbQuery = strapi.get('query-params').transform(RELEASE_MODEL_UID, query);\n      const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({\n        ...dbQuery,\n        where: { id },\n      });\n\n      return release;\n    },\n\n    findPage(query?: GetReleases.Request['query']) {\n      const dbQuery = strapi.get('query-params').transform(RELEASE_MODEL_UID, query ?? {});\n\n      return strapi.db.query(RELEASE_MODEL_UID).findPage({\n        ...dbQuery,\n        populate: {\n          actions: {\n            count: true,\n          },\n        },\n      });\n    },\n\n    findMany(query?: any) {\n      const dbQuery = strapi.get('query-params').transform(RELEASE_MODEL_UID, query ?? {});\n\n      return strapi.db.query(RELEASE_MODEL_UID).findMany({\n        ...dbQuery,\n      });\n    },\n\n    async update(\n      id: Data.ID,\n      releaseData: UpdateRelease.Request['body'],\n      { user }: { user: UserInfo }\n    ) {\n      const releaseWithCreatorFields = await setCreatorFields({ user, isEdition: true })(\n        releaseData\n      );\n\n      const { validateUniqueNameForPendingRelease, validateScheduledAtIsLaterThanNow } = getService(\n        'release-validation',\n        { strapi }\n      );\n\n      await Promise.all([\n        validateUniqueNameForPendingRelease(releaseWithCreatorFields.name, id),\n        validateScheduledAtIsLaterThanNow(releaseWithCreatorFields.scheduledAt),\n      ]);\n\n      const release = await strapi.db.query(RELEASE_MODEL_UID).findOne({ where: { id } });\n\n      if (!release) {\n        throw new errors.NotFoundError(`No release found for id ${id}`);\n      }\n\n      if (release.releasedAt) {\n        throw new errors.ValidationError('Release already published');\n      }\n\n      const updatedRelease = await strapi.db.query(RELEASE_MODEL_UID).update({\n        where: { id },\n        data: releaseWithCreatorFields,\n      });\n\n      const schedulingService = getService('scheduling', { strapi });\n\n      if (releaseData.scheduledAt) {\n        // set function always cancel the previous job if it exists, so we can call it directly\n        await schedulingService.set(id, releaseData.scheduledAt);\n      } else if (release.scheduledAt) {\n        // When user don't send a scheduledAt and we have one on the release, means that user want to unschedule it\n        schedulingService.cancel(id);\n      }\n\n      this.updateReleaseStatus(id);\n\n      strapi.telemetry.send('didUpdateContentRelease');\n\n      return updatedRelease;\n    },\n\n    async getAllComponents() {\n      const contentManagerComponentsService = strapi\n        .plugin('content-manager')\n        .service('components');\n\n      const components = await contentManagerComponentsService.findAllComponents();\n\n      const componentsMap = components.reduce(\n        (\n          acc: { [key: Struct.ComponentSchema['uid']]: Struct.ComponentSchema },\n          component: Struct.ComponentSchema\n        ) => {\n          acc[component.uid] = component;\n\n          return acc;\n        },\n        {}\n      );\n\n      return componentsMap;\n    },\n\n    async delete(releaseId: DeleteRelease.Request['params']['id']) {\n      const release: Release = await strapi.db.query(RELEASE_MODEL_UID).findOne({\n        where: { id: releaseId },\n        populate: {\n          actions: {\n            select: ['id'],\n          },\n        },\n      });\n\n      if (!release) {\n        throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n      }\n\n      if (release.releasedAt) {\n        throw new errors.ValidationError('Release already published');\n      }\n\n      // Only delete the release and its actions is you in fact can delete all the actions and the release\n      // Otherwise, if the transaction fails it throws an error\n      await strapi.db.transaction(async () => {\n        await strapi.db.query(RELEASE_ACTION_MODEL_UID).deleteMany({\n          where: {\n            id: {\n              $in: release.actions.map((action) => action.id),\n            },\n          },\n        });\n\n        await strapi.db.query(RELEASE_MODEL_UID).delete({\n          where: {\n            id: releaseId,\n          },\n        });\n      });\n\n      if (release.scheduledAt) {\n        const schedulingService = getService('scheduling', { strapi });\n        await schedulingService.cancel(release.id);\n      }\n\n      strapi.telemetry.send('didDeleteContentRelease');\n\n      return release;\n    },\n\n    async publish(releaseId: PublishRelease.Request['params']['id']) {\n      const {\n        release,\n        error,\n      }: { release: Pick<Release, 'id' | 'releasedAt' | 'status'> | null; error: unknown | null } =\n        await strapi.db.transaction(async ({ trx }) => {\n          /**\n           * We lock the release in this transaction, so any other process trying to publish it will wait until this transaction is finished\n           * In this transaction we don't care about rollback, becasue we want to persist the lock until the end and if it fails we want to change the release status to failed\n           */\n          const lockedRelease = (await strapi.db\n            ?.queryBuilder(RELEASE_MODEL_UID)\n            .where({ id: releaseId })\n            .select(['id', 'name', 'releasedAt', 'status'])\n            .first()\n            .transacting(trx)\n            .forUpdate()\n            .execute()) as Pick<Release, 'id' | 'name' | 'releasedAt' | 'status'> | undefined;\n\n          if (!lockedRelease) {\n            throw new errors.NotFoundError(`No release found for id ${releaseId}`);\n          }\n\n          if (lockedRelease.releasedAt) {\n            throw new errors.ValidationError('Release already published');\n          }\n\n          if (lockedRelease.status === 'failed') {\n            throw new errors.ValidationError('Release failed to publish');\n          }\n\n          try {\n            strapi.log.info(`[Content Releases] Starting to publish release ${lockedRelease.name}`);\n\n            const formattedActions = await getFormattedActions(releaseId);\n\n            await strapi.db.transaction(async () =>\n              Promise.all(\n                Object.keys(formattedActions).map(async (contentTypeUid) => {\n                  const contentType = contentTypeUid as UID.ContentType;\n                  const { publish, unpublish } = formattedActions[contentType];\n\n                  return Promise.all([\n                    ...publish.map((params) => strapi.documents(contentType).publish(params)),\n                    ...unpublish.map((params) => strapi.documents(contentType).unpublish(params)),\n                  ]);\n                })\n              )\n            );\n\n            const release = await strapi.db.query(RELEASE_MODEL_UID).update({\n              where: {\n                id: releaseId,\n              },\n              data: {\n                status: 'done',\n                releasedAt: new Date(),\n              },\n            });\n\n            dispatchWebhook(ALLOWED_WEBHOOK_EVENTS.RELEASES_PUBLISH, {\n              isPublished: true,\n              release,\n            });\n\n            strapi.telemetry.send('didPublishContentRelease');\n\n            return { release, error: null };\n          } catch (error) {\n            dispatchWebhook(ALLOWED_WEBHOOK_EVENTS.RELEASES_PUBLISH, {\n              isPublished: false,\n              error,\n            });\n\n            // We need to run the update in the same transaction because the release is locked\n            await strapi.db\n              ?.queryBuilder(RELEASE_MODEL_UID)\n              .where({ id: releaseId })\n              .update({\n                status: 'failed',\n              })\n              .transacting(trx)\n              .execute();\n\n            // At this point, we don't want to throw the error because if that happen we rollback the change in the release status\n            // We want to throw the error after the transaction is finished, so we return the error\n            return {\n              release: null,\n              error,\n            };\n          }\n        });\n\n      // Now the first transaction is commited, we can safely throw the error if it exists\n      if (error instanceof Error) {\n        throw error;\n      }\n\n      return release;\n    },\n\n    async updateReleaseStatus(releaseId: Release['id']) {\n      const releaseActionService = getService('release-action', { strapi });\n\n      const [totalActions, invalidActions] = await Promise.all([\n        releaseActionService.countActions({\n          filters: {\n            release: releaseId,\n          },\n        }),\n        releaseActionService.countActions({\n          filters: {\n            release: releaseId,\n            isEntryValid: false,\n          },\n        }),\n      ]);\n\n      if (totalActions > 0) {\n        if (invalidActions > 0) {\n          return strapi.db.query(RELEASE_MODEL_UID).update({\n            where: {\n              id: releaseId,\n            },\n            data: {\n              status: 'blocked',\n            },\n          });\n        }\n\n        return strapi.db.query(RELEASE_MODEL_UID).update({\n          where: {\n            id: releaseId,\n          },\n          data: {\n            status: 'ready',\n          },\n        });\n      }\n\n      return strapi.db.query(RELEASE_MODEL_UID).update({\n        where: {\n          id: releaseId,\n        },\n        data: {\n          status: 'empty',\n        },\n      });\n    },\n  };\n};\n\nexport type ReleaseService = ReturnType<typeof createReleaseService>;\n\nexport default createReleaseService;\n"],"names":["createReleaseService","strapi","dispatchWebhook","event","isPublished","release","error","eventHub","emit","getFormattedActions","releaseId","actions","db","query","RELEASE_ACTION_MODEL_UID","findMany","where","id","length","errors","ValidationError","formattedActions","action","contentTypeUid","contentType","publish","unpublish","type","push","documentId","entryDocumentId","locale","create","releaseData","user","releaseWithCreatorFields","setCreatorFields","validatePendingReleasesLimit","validateUniqueNameForPendingRelease","validateScheduledAtIsLaterThanNow","getService","Promise","all","name","scheduledAt","RELEASE_MODEL_UID","data","status","schedulingService","set","telemetry","send","findOne","dbQuery","get","transform","findPage","populate","count","update","isEdition","NotFoundError","releasedAt","updatedRelease","cancel","updateReleaseStatus","getAllComponents","contentManagerComponentsService","plugin","service","components","findAllComponents","componentsMap","reduce","acc","component","uid","delete","select","transaction","deleteMany","$in","map","trx","lockedRelease","queryBuilder","first","transacting","forUpdate","execute","log","info","Object","keys","params","documents","Date","ALLOWED_WEBHOOK_EVENTS","RELEASES_PUBLISH","Error","releaseActionService","totalActions","invalidActions","countActions","filters","isEntryValid"],"mappings":"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"}