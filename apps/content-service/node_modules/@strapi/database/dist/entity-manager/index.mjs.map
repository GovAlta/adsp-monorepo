{"version":3,"file":"index.mjs","sources":["../../src/entity-manager/index.ts"],"sourcesContent":["import {\n  castArray,\n  compact,\n  difference,\n  differenceWith,\n  has,\n  isArray,\n  isEmpty,\n  isEqual,\n  isInteger,\n  isNil,\n  isNull,\n  isNumber,\n  isObject,\n  isPlainObject,\n  isString,\n  isUndefined,\n  map,\n  pick,\n  uniqBy,\n  uniqWith,\n} from 'lodash/fp';\n\nimport * as types from '../utils/types';\nimport { createField } from '../fields';\nimport { createQueryBuilder } from '../query';\nimport { createRepository } from './entity-repository';\nimport {\n  deleteRelatedMorphOneRelationsAfterMorphToManyUpdate,\n  encodePolymorphicRelation,\n  encodePolymorphicId,\n} from './morph-relations';\nimport {\n  isBidirectional,\n  isAnyToOne,\n  isOneToAny,\n  hasOrderColumn,\n  hasInverseOrderColumn,\n} from '../metadata';\nimport {\n  deletePreviousOneToAnyRelations,\n  deletePreviousAnyToOneRelations,\n  deleteRelations,\n  cleanOrderColumns,\n} from './regular-relations';\nimport { relationsOrderer } from './relations-orderer';\nimport type { Database } from '..';\nimport type { Meta } from '../metadata';\nimport type { ID } from '../types';\nimport { EntityManager, Repository, Entity } from './types';\n\nexport * from './types';\n\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\n  isObject(value) && !isNil(value);\n\nconst toId = (value: unknown | { id: unknown }): ID => {\n  if (isRecord(value) && 'id' in value && isValidId(value.id)) {\n    return value.id;\n  }\n\n  if (isValidId(value)) {\n    return value;\n  }\n\n  throw new Error(`Invalid id, expected a string or integer, got ${JSON.stringify(value)}`);\n};\nconst toIds = (value: unknown): ID[] => castArray(value || []).map(toId);\n\nconst isValidId = (value: unknown): value is ID => isString(value) || isInteger(value);\n\nconst isValidObjectId = (value: unknown): value is Entity =>\n  isRecord(value) && 'id' in value && isValidId(value.id);\n\nconst toIdArray = (\n  data: unknown\n): {\n  id: ID;\n  __pivot?: { [key: string]: any };\n  [key: string]: any;\n}[] => {\n  const array = castArray(data)\n    .filter((datum) => !isNil(datum))\n    .map((datum) => {\n      // if it is a string or an integer return an obj with id = to datum\n      if (isValidId(datum)) {\n        return { id: datum, __pivot: {} };\n      }\n\n      // if it is an object check it has at least a valid id\n      if (!isValidObjectId(datum)) {\n        throw new Error(`Invalid id, expected a string or integer, got ${datum}`);\n      }\n\n      return datum;\n    });\n\n  return uniqWith(isEqual, array);\n};\n\ntype ScalarAssoc = string | number | null;\ntype Assocs =\n  | ScalarAssoc\n  | { id: ScalarAssoc | Array<ScalarAssoc> }\n  | Array<ScalarAssoc>\n  | {\n      set?: Array<ScalarAssoc> | null;\n      options?: { strict?: boolean };\n      connect?: Array<{\n        id: ScalarAssoc;\n        position?: { start?: boolean; end?: boolean; before?: ID; after?: ID };\n        __pivot?: any;\n        __type?: any;\n      }> | null;\n      disconnect?: Array<ScalarAssoc> | null;\n    };\n\nconst toAssocs = (data: Assocs) => {\n  if (\n    isArray(data) ||\n    isString(data) ||\n    isNumber(data) ||\n    isNull(data) ||\n    (isRecord(data) && 'id' in data)\n  ) {\n    return {\n      set: isNull(data) ? data : toIdArray(data),\n    };\n  }\n\n  if (data?.set) {\n    return {\n      set: isNull(data.set) ? data.set : toIdArray(data.set),\n    };\n  }\n\n  return {\n    options: {\n      strict: data?.options?.strict,\n    },\n    connect: toIdArray(data?.connect).map((elm) => ({\n      id: elm.id,\n      position: elm.position ? elm.position : { end: true },\n      __pivot: elm.__pivot ?? {},\n      __type: elm.__type,\n    })),\n    disconnect: toIdArray(data?.disconnect),\n  };\n};\n\nconst processData = (\n  metadata: Meta,\n  data: Record<string, unknown> = {},\n  { withDefaults = false } = {}\n) => {\n  const { attributes } = metadata;\n\n  const obj: Record<string, unknown> = {};\n\n  for (const attributeName of Object.keys(attributes)) {\n    const attribute = attributes[attributeName];\n\n    if (types.isScalarAttribute(attribute)) {\n      const field = createField(attribute);\n\n      if (isUndefined(data[attributeName])) {\n        if (!isUndefined(attribute.default) && withDefaults) {\n          if (typeof attribute.default === 'function') {\n            obj[attributeName] = attribute.default();\n          } else {\n            obj[attributeName] = attribute.default;\n          }\n        }\n        continue;\n      }\n\n      if (\n        'validate' in field &&\n        typeof field.validate === 'function' &&\n        data[attributeName] !== null\n      ) {\n        field.validate(data[attributeName]);\n      }\n\n      const val = data[attributeName] === null ? null : field.toDB(data[attributeName]);\n\n      obj[attributeName] = val;\n    }\n\n    if (types.isRelationalAttribute(attribute)) {\n      // oneToOne & manyToOne\n      if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n        const joinColumnName = attribute.joinColumn.name;\n\n        // allow setting to null\n        const attrValue = !isUndefined(data[attributeName])\n          ? data[attributeName]\n          : data[joinColumnName];\n\n        if (isNull(attrValue)) {\n          obj[joinColumnName] = attrValue;\n        } else if (!isUndefined(attrValue)) {\n          obj[joinColumnName] = toId(attrValue);\n        }\n\n        continue;\n      }\n\n      if ('morphColumn' in attribute && attribute.morphColumn && attribute.owner) {\n        const { idColumn, typeColumn, typeField = '__type' } = attribute.morphColumn;\n\n        const value = data[attributeName] as Record<string, unknown>;\n\n        if (value === null) {\n          Object.assign(obj, {\n            [idColumn.name]: null,\n            [typeColumn.name]: null,\n          });\n\n          continue;\n        }\n\n        if (!isUndefined(value)) {\n          if (!has('id', value) || !has(typeField, value)) {\n            throw new Error(`Expects properties ${typeField} an id to make a morph association`);\n          }\n\n          Object.assign(obj, {\n            [idColumn.name]: value.id,\n            [typeColumn.name]: value[typeField],\n          });\n        }\n      }\n    }\n  }\n\n  return obj;\n};\nexport const createEntityManager = (db: Database): EntityManager => {\n  const repoMap: Record<string, Repository> = {};\n\n  return {\n    async findOne(uid, params) {\n      const states = await db.lifecycles.run('beforeFindOne', uid, { params });\n\n      const result = await this.createQueryBuilder(uid)\n        .init(params)\n        .first()\n        .execute<Entity | null>();\n\n      await db.lifecycles.run('afterFindOne', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // should we name it findOne because people are used to it ?\n    async findMany(uid, params) {\n      const states = await db.lifecycles.run('beforeFindMany', uid, { params });\n\n      const result = await this.createQueryBuilder(uid).init(params).execute<any[]>();\n\n      await db.lifecycles.run('afterFindMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async count(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCount', uid, { params });\n\n      const res = await this.createQueryBuilder(uid)\n        .init(pick(['_q', 'where', 'filters'], params))\n        .count()\n        .first()\n        .execute<{ count: number }>();\n\n      const result = Number(res.count);\n\n      await db.lifecycles.run('afterCount', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async create(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCreate', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { data } = params;\n\n      if (!isPlainObject(data)) {\n        throw new Error('Create expects a data object');\n      }\n\n      const dataToInsert = processData(metadata, data, { withDefaults: true });\n\n      const res = await this.createQueryBuilder(uid)\n        .insert(dataToInsert)\n        .execute<Array<ID | { id: ID }>>();\n\n      const id = isRecord(res[0]) ? res[0].id : res[0];\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.attachRelations(uid, id, data, { transaction: trx.get() });\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        await this.createQueryBuilder(uid).where({ id }).delete().execute();\n        throw e;\n      }\n\n      // TODO: in case there is no select or populate specified return the inserted data ?\n      // TODO: do not trigger the findOne lifecycles ?\n      const result = await this.findOne(uid, {\n        where: { id },\n        select: params.select,\n        populate: params.populate,\n        filters: params.filters,\n      });\n\n      await db.lifecycles.run('afterCreate', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async createMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeCreateMany', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { data } = params;\n\n      if (!isArray(data)) {\n        throw new Error('CreateMany expects data to be an array');\n      }\n\n      const dataToInsert = data.map((datum) =>\n        processData(metadata, datum, { withDefaults: true })\n      );\n\n      if (isEmpty(dataToInsert)) {\n        throw new Error('Nothing to insert');\n      }\n\n      const createdEntries = await this.createQueryBuilder(uid)\n        .insert(dataToInsert)\n        .execute<Array<ID | { id: ID }>>();\n\n      const result = {\n        count: data.length,\n        ids: createdEntries.map((entry) => (typeof entry === 'object' ? entry?.id : entry)),\n      };\n\n      await db.lifecycles.run('afterCreateMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async update(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeUpdate', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { where, data } = params;\n\n      if (!isPlainObject(data)) {\n        throw new Error('Update requires a data object');\n      }\n\n      if (isEmpty(where)) {\n        throw new Error('Update requires a where parameter');\n      }\n\n      const entity = await this.createQueryBuilder(uid)\n        .select('*')\n        .where(where)\n        .first()\n        .execute<{ id: ID }>({ mapResults: false });\n\n      if (!entity) {\n        return null;\n      }\n\n      const { id } = entity;\n\n      const dataToUpdate = processData(metadata, data);\n\n      if (!isEmpty(dataToUpdate)) {\n        await this.createQueryBuilder(uid).where({ id }).update(dataToUpdate).execute();\n      }\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.updateRelations(uid, id, data, { transaction: trx.get() });\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        await this.createQueryBuilder(uid).where({ id }).update(entity).execute();\n        throw e;\n      }\n\n      // TODO: do not trigger the findOne lifecycles ?\n      const result = await this.findOne(uid, {\n        where: { id },\n        select: params.select,\n        populate: params.populate,\n        filters: params.filters,\n      });\n\n      await db.lifecycles.run('afterUpdate', uid, { params, result }, states);\n\n      return result;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async updateMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeUpdateMany', uid, { params });\n\n      const metadata = db.metadata.get(uid);\n      const { where, data } = params;\n\n      const dataToUpdate = processData(metadata, data);\n\n      if (isEmpty(dataToUpdate)) {\n        throw new Error('Update requires data');\n      }\n\n      const updatedRows = await this.createQueryBuilder(uid)\n        .where(where)\n        .update(dataToUpdate)\n        .execute<number>();\n\n      const result = { count: updatedRows };\n\n      await db.lifecycles.run('afterUpdateMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    async delete(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeDelete', uid, { params });\n\n      const { where, select, populate } = params;\n\n      if (isEmpty(where)) {\n        throw new Error('Delete requires a where parameter');\n      }\n\n      // TODO: do not trigger the findOne lifecycles ?\n      const entity = await this.findOne(uid, {\n        select: select && ['id'].concat(select),\n        where,\n        populate,\n      });\n\n      if (!entity) {\n        return null;\n      }\n\n      const { id } = entity;\n\n      await this.createQueryBuilder(uid).where({ id }).delete().execute();\n\n      const trx = await strapi.db.transaction();\n      try {\n        await this.deleteRelations(uid, id, { transaction: trx.get() });\n\n        await trx.commit();\n      } catch (e) {\n        await trx.rollback();\n        throw e;\n      }\n\n      await db.lifecycles.run('afterDelete', uid, { params, result: entity }, states);\n\n      return entity;\n    },\n\n    // TODO: where do we handle relation processing for many queries ?\n    async deleteMany(uid, params = {}) {\n      const states = await db.lifecycles.run('beforeDeleteMany', uid, { params });\n\n      const { where } = params;\n\n      const deletedRows = await this.createQueryBuilder(uid)\n        .where(where)\n        .delete()\n        .execute<number>({ mapResults: false });\n\n      const result = { count: deletedRows };\n\n      await db.lifecycles.run('afterDeleteMany', uid, { params, result }, states);\n\n      return result;\n    },\n\n    /**\n     * Attach relations to a new entity\n     */\n    async attachRelations(uid, id, data, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        const isValidLink = has(attributeName, data) && !isNil(data[attributeName]);\n\n        if (attribute.type !== 'relation' || !isValidLink) {\n          continue;\n        }\n\n        const cleanRelationData = toAssocs(data[attributeName]);\n\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          /**\n           * morphOne and morphMany relations\n           */\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n          if (targetAttribute.type !== 'relation') {\n            throw new Error(\n              `Expected target attribute ${target}.${morphBy} to be a relation attribute`\n            );\n          }\n\n          if (targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            const relId = toId(cleanRelationData.set?.[0]);\n\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .where({ id: relId })\n              .transacting(trx)\n              .execute();\n          } else if (targetAttribute.relation === 'morphToMany') {\n            const { joinTable } = targetAttribute;\n            const { joinColumn, morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            if (isEmpty(cleanRelationData.set)) {\n              continue;\n            }\n\n            const rows =\n              cleanRelationData.set?.map((data, idx) => {\n                return {\n                  [joinColumn.name]: data.id,\n                  [idColumn.name]: id,\n                  [typeColumn.name]: uid,\n                  ...(('on' in joinTable && joinTable.on) || {}),\n                  ...(data.__pivot || {}),\n                  order: idx + 1,\n                  field: attributeName,\n                };\n              }) ?? [];\n\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n          }\n\n          continue;\n        } else if (attribute.relation === 'morphToOne') {\n          /**\n           * morphToOne\n           */\n          // handled on the entry itself\n          continue;\n        } else if (attribute.relation === 'morphToMany') {\n          /**\n           * morphToMany\n           */\n          const { joinTable } = attribute;\n          const { joinColumn, morphColumn } = joinTable;\n\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n          if (isEmpty(cleanRelationData.set) && isEmpty(cleanRelationData.connect)) {\n            continue;\n          }\n\n          // set happens before connect/disconnect\n          const dataset = cleanRelationData.set || cleanRelationData.connect || [];\n\n          const rows = dataset.map((data, idx) => ({\n            [joinColumn.name]: id,\n            [idColumn.name]: data.id,\n            [typeColumn.name]: data[typeField as '__type'],\n            ...(('on' in joinTable && joinTable.on) || {}),\n            ...(data.__pivot || {}),\n            order: idx + 1,\n          })) satisfies Record<string, any>[];\n\n          const orderMap = relationsOrderer(\n            [],\n            morphColumn.idColumn.name,\n            'order',\n            true // Always make a strict connect when inserting\n          )\n            .connect(\n              // Merge id & __type to get a single id key\n              dataset.map(encodePolymorphicRelation({ idColumn: 'id', typeColumn: typeField }))\n            )\n            .get()\n            // set the order based on the order of the ids\n            .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx + 1 }), {} as Record<ID, number>);\n\n          rows.forEach((row: Record<string, unknown>) => {\n            const rowId = row[morphColumn.idColumn.name] as ID;\n            const rowType = row[morphColumn.typeColumn.name] as string;\n            const encodedId = encodePolymorphicId(rowId, rowType);\n\n            row.order = orderMap[encodedId];\n          });\n\n          // delete previous relations\n          await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows as any, {\n            uid,\n            attributeName,\n            joinTable,\n            db,\n            transaction: trx,\n          });\n\n          await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n\n          continue;\n        }\n\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          const relIdsToAdd = toIds(cleanRelationData.set);\n          if (\n            attribute.relation === 'oneToOne' &&\n            isBidirectional(attribute) &&\n            relIdsToAdd.length\n          ) {\n            await this.createQueryBuilder(uid)\n              .where({ [attribute.joinColumn.name]: relIdsToAdd, id: { $ne: id } })\n              .update({ [attribute.joinColumn.name]: null })\n              .transacting(trx)\n              .execute();\n          }\n\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          // TODO: check it is an id & the entity exists (will throw due to FKs otherwise so not a big pbl in SQL)\n          const relIdsToAdd = toIds(cleanRelationData.set);\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n\n          await this.createQueryBuilder(target)\n            .update({ [attribute.joinColumn.referencedColumn]: id })\n            // NOTE: works if it is an array or a single id\n            .where({ id: relIdsToAdd })\n            .transacting(trx)\n            .execute();\n        }\n\n        if ('joinTable' in attribute && attribute.joinTable) {\n          // need to set the column on the target\n\n          const { joinTable } = attribute;\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\n            joinTable;\n\n          const relsToAdd = (cleanRelationData.set || cleanRelationData.connect) ?? [];\n          const relIdsToadd = toIds(relsToAdd);\n\n          if (isBidirectional(attribute) && isOneToAny(attribute)) {\n            await deletePreviousOneToAnyRelations({\n              id,\n              attribute,\n              relIdsToadd,\n              db,\n              transaction: trx,\n            });\n          }\n\n          // prepare new relations to insert\n          const insert = uniqBy('id', relsToAdd).map((data) => {\n            return {\n              [joinColumn.name]: id,\n              [inverseJoinColumn.name]: data.id,\n              ...(('on' in joinTable && joinTable.on) || {}),\n              ...(data.__pivot || {}),\n            };\n          }) satisfies Record<string, any>[];\n\n          // add order value\n          if (cleanRelationData.set && hasOrderColumn(attribute)) {\n            insert.forEach((data: Record<string, unknown>, idx) => {\n              data[orderColumnName] = idx + 1;\n            });\n          } else if (cleanRelationData.connect && hasOrderColumn(attribute)) {\n            // use position attributes to calculate order\n            const orderMap = relationsOrderer(\n              [],\n              inverseJoinColumn.name,\n              joinTable.orderColumnName,\n              true // Always make an strict connect when inserting\n            )\n              .connect(relsToAdd)\n              .get()\n              // set the order based on the order of the ids\n              .reduce((acc, rel, idx) => ({ ...acc, [rel.id]: idx }), {} as Record<ID, number>);\n\n            insert.forEach((row: Record<string, unknown>) => {\n              row[orderColumnName] = orderMap[row[inverseJoinColumn.name] as number];\n            });\n          }\n\n          // add inv_order value\n          if (hasInverseOrderColumn(attribute)) {\n            const maxResults = await db\n              .getConnection()\n              .select(inverseJoinColumn.name)\n              .max(inverseOrderColumnName, { as: 'max' })\n              .whereIn(inverseJoinColumn.name, relIdsToadd)\n              .where(joinTable.on || {})\n              .groupBy(inverseJoinColumn.name)\n              .from(joinTable.name)\n              .transacting(trx);\n\n            const maxMap = maxResults.reduce(\n              (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n              {} as Record<string, number>\n            );\n\n            insert.forEach((rel) => {\n              rel[inverseOrderColumnName] = (maxMap[rel[inverseJoinColumn.name]] || 0) + 1;\n            });\n          }\n\n          if (insert.length === 0) {\n            continue;\n          }\n\n          // insert new relations\n          await this.createQueryBuilder(joinTable.name).insert(insert).transacting(trx).execute();\n        }\n      }\n    },\n\n    /**\n     * Updates relations of an existing entity\n     */\n    // TODO: check relation exists (handled by FKs except for polymorphics)\n    async updateRelations(uid, id, data, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        if (attribute.type !== 'relation' || !has(attributeName, data)) {\n          continue;\n        }\n        const cleanRelationData = toAssocs(data[attributeName]);\n\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            // update instead of deleting because the relation is directly on the entity table\n            // and not in a join table\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .transacting(trx)\n              .execute();\n\n            if (!isNull(cleanRelationData.set)) {\n              const relId = toIds(cleanRelationData.set?.[0]);\n              await this.createQueryBuilder(target)\n                .update({ [idColumn.name]: id, [typeColumn.name]: uid })\n                .where({ id: relId })\n                .transacting(trx)\n                .execute();\n            }\n          } else if (\n            targetAttribute.type === 'relation' &&\n            targetAttribute.relation === 'morphToMany'\n          ) {\n            const { joinTable } = targetAttribute;\n            const { joinColumn, morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            const hasSet = !isEmpty(cleanRelationData.set);\n            const hasConnect = !isEmpty(cleanRelationData.connect);\n            const hasDisconnect = !isEmpty(cleanRelationData.disconnect);\n\n            // for connect/disconnect without a set, only modify those relations\n            if (!hasSet && (hasConnect || hasDisconnect)) {\n              // delete disconnects and connects (to prevent duplicates when we add them later)\n              const idsToDelete = [\n                ...(cleanRelationData.disconnect || []),\n                ...(cleanRelationData.connect || []),\n              ];\n\n              if (!isEmpty(idsToDelete)) {\n                const where = {\n                  $or: idsToDelete.map((item: any) => {\n                    return {\n                      [idColumn.name]: id,\n                      [typeColumn.name]: uid,\n                      [joinColumn.name]: item.id,\n                      ...(joinTable.on || {}),\n                      field: attributeName,\n                    };\n                  }),\n                };\n\n                await this.createQueryBuilder(joinTable.name)\n                  .delete()\n                  .where(where)\n                  .transacting(trx)\n                  .execute();\n              }\n\n              // connect relations\n              if (hasConnect) {\n                // Query database to find the order of the last relation\n                const start = await this.createQueryBuilder(joinTable.name)\n                  .where({\n                    [idColumn.name]: id,\n                    [typeColumn.name]: uid,\n                    ...(joinTable.on || {}),\n                    ...(data.__pivot || {}),\n                  })\n                  .max('order')\n                  .first()\n                  .transacting(trx)\n                  .execute();\n\n                const startOrder = (start as any)?.max || 0;\n\n                const rows = (cleanRelationData.connect ?? []).map((data, idx) => ({\n                  [joinColumn.name]: data.id,\n                  [idColumn.name]: id,\n                  [typeColumn.name]: uid,\n                  ...(joinTable.on || {}),\n                  ...(data.__pivot || {}),\n                  order: startOrder + idx + 1,\n                  field: attributeName,\n                })) satisfies Record<string, any>[];\n\n                await this.createQueryBuilder(joinTable.name)\n                  .insert(rows)\n                  .transacting(trx)\n                  .execute();\n              }\n\n              continue;\n            }\n\n            // delete all relations\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                field: attributeName,\n              })\n              .transacting(trx)\n              .execute();\n\n            if (hasSet) {\n              const rows = (cleanRelationData.set ?? []).map((data, idx) => ({\n                [joinColumn.name]: data.id,\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                ...(data.__pivot || {}),\n                order: idx + 1,\n                field: attributeName,\n              })) satisfies Record<string, any>[];\n\n              await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n            }\n          }\n\n          continue;\n        }\n\n        if (attribute.relation === 'morphToOne') {\n          // handled on the entry itself\n          continue;\n        }\n\n        if (attribute.relation === 'morphToMany') {\n          const { joinTable } = attribute;\n          const { joinColumn, morphColumn } = joinTable;\n\n          const { idColumn, typeColumn, typeField = '__type' } = morphColumn;\n\n          const hasSet = !isEmpty(cleanRelationData.set);\n          const hasConnect = !isEmpty(cleanRelationData.connect);\n          const hasDisconnect = !isEmpty(cleanRelationData.disconnect);\n\n          // for connect/disconnect without a set, only modify those relations\n          if (!hasSet && (hasConnect || hasDisconnect)) {\n            // delete disconnects and connects (to prevent duplicates when we add them later)\n            const idsToDelete = [\n              ...(cleanRelationData.disconnect || []),\n              ...(cleanRelationData.connect || []),\n            ];\n\n            const rowsToDelete = [\n              ...(cleanRelationData.disconnect ?? []).map((data, idx) => ({\n                [joinColumn.name]: id,\n                [idColumn.name]: data.id,\n                [typeColumn.name]: data[typeField],\n                ...(('on' in joinTable && joinTable.on) || {}),\n                ...(data.__pivot || {}),\n                order: idx + 1,\n              })),\n              ...(cleanRelationData.connect ?? []).map((data, idx) => ({\n                [joinColumn.name]: id,\n                [idColumn.name]: data.id,\n                // @ts-expect-error TODO\n                [typeColumn.name]: data[typeField],\n                ...(('on' in joinTable && joinTable.on) || {}),\n                ...(data.__pivot || {}),\n                order: idx + 1,\n              })),\n            ];\n\n            const adjacentRelations = await this.createQueryBuilder(joinTable.name)\n              .where({\n                $or: [\n                  {\n                    [joinColumn.name]: id,\n                    [idColumn.name]: {\n                      $in: compact(\n                        cleanRelationData.connect?.map(\n                          (r) => r.position?.after || r.position?.before\n                        )\n                      ),\n                    },\n                  },\n                  {\n                    [joinColumn.name]: id,\n                    order: this.createQueryBuilder(joinTable.name)\n                      .max('order')\n                      .where({ [joinColumn.name]: id })\n                      .where(joinTable.on || {})\n                      .transacting(trx)\n                      .getKnexQuery(),\n                  },\n                ],\n              })\n              .where(joinTable.on || {})\n              .transacting(trx)\n              .execute<Array<Record<string, any>>>();\n\n            if (!isEmpty(idsToDelete)) {\n              const where = {\n                $or: idsToDelete.map((item: any) => {\n                  return {\n                    [idColumn.name]: item.id,\n                    [typeColumn.name]: item[typeField],\n                    [joinColumn.name]: id,\n                    ...(joinTable.on || {}),\n                  };\n                }),\n              };\n\n              // delete previous relations\n              await this.createQueryBuilder(joinTable.name)\n                .delete()\n                .where(where)\n                .transacting(trx)\n                .execute();\n\n              await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rowsToDelete as any, {\n                uid,\n                attributeName,\n                joinTable,\n                db,\n                transaction: trx,\n              });\n            }\n\n            // connect relations\n            if (hasConnect) {\n              const dataset = cleanRelationData.connect || [];\n\n              const rows = dataset.map((data) => ({\n                [joinColumn.name]: id,\n                [idColumn.name]: data.id,\n                [typeColumn.name]: data[typeField as '__type'],\n                ...(joinTable.on || {}),\n                ...(data.__pivot || {}),\n                field: attributeName,\n              })) satisfies Record<string, any>[];\n\n              const orderMap = relationsOrderer(\n                // Merge id & __type to get a single id key\n                adjacentRelations.map(\n                  encodePolymorphicRelation({\n                    idColumn: idColumn.name,\n                    typeColumn: typeColumn.name,\n                  })\n                ),\n                idColumn.name,\n                'order',\n                cleanRelationData.options?.strict\n              )\n                .connect(\n                  // Merge id & __type to get a single id key\n                  dataset.map(encodePolymorphicRelation({ idColumn: 'id', typeColumn: '__type' }))\n                )\n                .getOrderMap();\n\n              rows.forEach((row: Record<string, unknown>) => {\n                const rowId = row[idColumn.name] as number;\n                const rowType = row[typeColumn.name] as string;\n                const encodedId = encodePolymorphicId(rowId, rowType);\n\n                row.order = orderMap[encodedId];\n              });\n\n              await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n            }\n\n            continue;\n          }\n\n          if (hasSet) {\n            // delete all relations for this entity\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [joinColumn.name]: id,\n                ...(joinTable.on || {}),\n              })\n              .transacting(trx)\n              .execute();\n\n            const rows = (cleanRelationData.set ?? []).map((data, idx) => ({\n              [joinColumn.name]: id,\n              [idColumn.name]: data.id,\n              [typeColumn.name]: data[typeField],\n              field: attributeName,\n              ...(joinTable.on || {}),\n              ...(data.__pivot || {}),\n              order: idx + 1,\n            })) satisfies Record<string, any>[];\n\n            await deleteRelatedMorphOneRelationsAfterMorphToManyUpdate(rows, {\n              uid,\n              attributeName,\n              joinTable,\n              db,\n              transaction: trx,\n            });\n\n            await this.createQueryBuilder(joinTable.name).insert(rows).transacting(trx).execute();\n          }\n\n          continue;\n        }\n\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          // handled in the row itself\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side.\n        // Since it is a join column no need to remove previous relations\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n\n          if (!isNull(cleanRelationData.set)) {\n            const relIdsToAdd = toIds(cleanRelationData.set);\n            await this.createQueryBuilder(target)\n              .where({ id: relIdsToAdd })\n              .update({ [attribute.joinColumn.referencedColumn]: id })\n              .transacting(trx)\n              .execute();\n          }\n        }\n\n        if (attribute.joinTable) {\n          const { joinTable } = attribute;\n          const { joinColumn, inverseJoinColumn, orderColumnName, inverseOrderColumnName } =\n            joinTable;\n          const select = [joinColumn.name, inverseJoinColumn.name];\n          if (hasOrderColumn(attribute)) {\n            select.push(orderColumnName);\n          }\n          if (hasInverseOrderColumn(attribute)) {\n            select.push(inverseOrderColumnName);\n          }\n\n          // only delete relations\n          if (isNull(cleanRelationData.set)) {\n            await deleteRelations({ id, attribute, db, relIdsToDelete: 'all', transaction: trx });\n          } else {\n            const isPartialUpdate = !has('set', cleanRelationData);\n            let relIdsToaddOrMove: ID[];\n\n            if (isPartialUpdate) {\n              if (isAnyToOne(attribute)) {\n                // TODO: V5 find a fix to connect multiple versions of a document at the same time on xToOne relations\n                // cleanRelationData.connect = cleanRelationData.connect?.slice(-1);\n              }\n              relIdsToaddOrMove = toIds(cleanRelationData.connect);\n              const relIdsToDelete = toIds(\n                differenceWith(\n                  isEqual,\n                  cleanRelationData.disconnect,\n                  cleanRelationData.connect ?? []\n                )\n              );\n\n              if (!isEmpty(relIdsToDelete)) {\n                await deleteRelations({ id, attribute, db, relIdsToDelete, transaction: trx });\n              }\n\n              if (isEmpty(cleanRelationData.connect)) {\n                continue;\n              }\n\n              // Fetch current relations to handle ordering\n              let currentMovingRels: Record<string, ID>[] = [];\n\n              if (hasOrderColumn(attribute) || hasInverseOrderColumn(attribute)) {\n                currentMovingRels = await this.createQueryBuilder(joinTable.name)\n                  .select(select)\n                  .where({\n                    [joinColumn.name]: id,\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute();\n              }\n\n              // prepare relations to insert\n              const insert = uniqBy('id', cleanRelationData.connect).map((relToAdd) => ({\n                [joinColumn.name]: id,\n                [inverseJoinColumn.name]: relToAdd.id,\n                ...(joinTable.on || {}),\n                ...(relToAdd.__pivot || {}),\n              }));\n\n              if (hasOrderColumn(attribute)) {\n                // Get all adjacent relations and the one with the highest order\n                const adjacentRelations = await this.createQueryBuilder(joinTable.name)\n                  .where({\n                    $or: [\n                      {\n                        [joinColumn.name]: id,\n                        [inverseJoinColumn.name]: {\n                          $in: compact(\n                            cleanRelationData.connect?.map(\n                              (r) => r.position?.after || r.position?.before\n                            )\n                          ),\n                        },\n                      },\n                      {\n                        [joinColumn.name]: id,\n                        [orderColumnName]: this.createQueryBuilder(joinTable.name)\n                          .max(orderColumnName)\n                          .where({ [joinColumn.name]: id })\n                          .where(joinTable.on || {})\n                          .transacting(trx)\n                          .getKnexQuery(),\n                      },\n                    ],\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute<Array<Record<string, any>>>();\n\n                const orderMap = relationsOrderer(\n                  adjacentRelations,\n                  inverseJoinColumn.name,\n                  joinTable.orderColumnName,\n                  cleanRelationData.options?.strict\n                )\n                  .connect(cleanRelationData.connect ?? [])\n                  .getOrderMap();\n\n                insert.forEach((row) => {\n                  row[orderColumnName] = orderMap[row[inverseJoinColumn.name]];\n                });\n              }\n\n              // add inv order value\n              if (hasInverseOrderColumn(attribute)) {\n                const nonExistingRelsIds: ID[] = difference(\n                  relIdsToaddOrMove,\n                  map(inverseJoinColumn.name, currentMovingRels)\n                );\n\n                const maxResults = await db\n                  .getConnection()\n                  .select(inverseJoinColumn.name)\n                  .max(inverseOrderColumnName, { as: 'max' })\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\n                  .where(joinTable.on || {})\n                  .groupBy(inverseJoinColumn.name)\n                  .from(joinTable.name)\n                  .transacting(trx);\n\n                const maxMap = maxResults.reduce(\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n                  {}\n                );\n\n                insert.forEach((row) => {\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\n                });\n              }\n\n              // insert rows\n              const query = this.createQueryBuilder(joinTable.name)\n                .insert(insert)\n                .onConflict(joinTable.pivotColumns)\n                .transacting(trx);\n\n              if (hasOrderColumn(attribute)) {\n                query.merge([orderColumnName]);\n              } else {\n                query.ignore();\n              }\n\n              await query.execute();\n\n              // remove gap between orders\n              await cleanOrderColumns({ attribute, db, id, transaction: trx });\n            } else {\n              if (isAnyToOne(attribute)) {\n                cleanRelationData.set = cleanRelationData.set?.slice(-1);\n              }\n              // overwrite all relations\n              relIdsToaddOrMove = toIds(cleanRelationData.set);\n              await deleteRelations({\n                id,\n                attribute,\n                db,\n                relIdsToDelete: 'all',\n                relIdsToNotDelete: relIdsToaddOrMove,\n                transaction: trx,\n              });\n\n              if (isEmpty(cleanRelationData.set)) {\n                continue;\n              }\n\n              const insert = uniqBy('id', cleanRelationData.set).map((relToAdd) => ({\n                [joinColumn.name]: id,\n                [inverseJoinColumn.name]: relToAdd.id,\n                ...(joinTable.on || {}),\n                ...(relToAdd.__pivot || {}),\n              }));\n\n              // add order value\n              if (hasOrderColumn(attribute)) {\n                insert.forEach((row, idx) => {\n                  row[orderColumnName] = idx + 1;\n                });\n              }\n\n              // add inv order value\n              if (hasInverseOrderColumn(attribute)) {\n                const existingRels = await this.createQueryBuilder(joinTable.name)\n                  .select(inverseJoinColumn.name)\n                  .where({\n                    [joinColumn.name]: id,\n                    [inverseJoinColumn.name]: { $in: relIdsToaddOrMove },\n                  })\n                  .where(joinTable.on || {})\n                  .transacting(trx)\n                  .execute<Array<Record<string, ID>>>();\n\n                const inverseRelsIds = map(inverseJoinColumn.name, existingRels);\n\n                const nonExistingRelsIds = difference(relIdsToaddOrMove, inverseRelsIds);\n\n                const maxResults = await db\n                  .getConnection()\n                  .select(inverseJoinColumn.name)\n                  .max(inverseOrderColumnName, { as: 'max' })\n                  .whereIn(inverseJoinColumn.name, nonExistingRelsIds)\n                  .where(joinTable.on || {})\n                  .groupBy(inverseJoinColumn.name)\n                  .from(joinTable.name)\n                  .transacting(trx);\n\n                const maxMap = maxResults.reduce(\n                  (acc, res) => Object.assign(acc, { [res[inverseJoinColumn.name]]: res.max }),\n                  {}\n                );\n\n                insert.forEach((row: any) => {\n                  row[inverseOrderColumnName] = (maxMap[row[inverseJoinColumn.name]] || 0) + 1;\n                });\n              }\n\n              // insert rows\n              const query = this.createQueryBuilder(joinTable.name)\n                .insert(insert)\n                .onConflict(joinTable.pivotColumns)\n                .transacting(trx);\n\n              if (hasOrderColumn(attribute)) {\n                query.merge([orderColumnName]);\n              } else {\n                query.ignore();\n              }\n\n              await query.execute();\n            }\n\n            // Delete the previous relations for oneToAny relations\n            if (isBidirectional(attribute) && isOneToAny(attribute)) {\n              await deletePreviousOneToAnyRelations({\n                id,\n                attribute,\n                relIdsToadd: relIdsToaddOrMove,\n                db,\n                transaction: trx,\n              });\n            }\n\n            // Delete the previous relations for anyToOne relations\n            if (isAnyToOne(attribute)) {\n              await deletePreviousAnyToOneRelations({\n                id,\n                attribute,\n                relIdToadd: relIdsToaddOrMove[0],\n                db,\n                transaction: trx,\n              });\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * Delete relational associations of an existing entity\n     * This removes associations but doesn't do cascade deletions for components for example. This will be handled on the entity service layer instead\n     * NOTE: Most of the deletion should be handled by ON DELETE CASCADE for dialects that have FKs\n     *\n     * @param {EntityManager} em - entity manager instance\n     * @param {Metadata} metadata - model metadta\n     * @param {ID} id - entity ID\n     */\n    async deleteRelations(uid, id, options) {\n      const { attributes } = db.metadata.get(uid);\n      const { transaction: trx } = options ?? {};\n\n      for (const attributeName of Object.keys(attributes)) {\n        const attribute = attributes[attributeName];\n\n        if (attribute.type !== 'relation') {\n          continue;\n        }\n\n        /*\n          if morphOne | morphMany\n            if morphBy is morphToOne\n              set null\n            if morphBy is morphToOne\n              delete links\n        */\n        if (attribute.relation === 'morphOne' || attribute.relation === 'morphMany') {\n          const { target, morphBy } = attribute;\n\n          const targetAttribute = db.metadata.get(target).attributes[morphBy];\n\n          if (targetAttribute.type === 'relation' && targetAttribute.relation === 'morphToOne') {\n            // set columns\n            const { idColumn, typeColumn } = targetAttribute.morphColumn;\n\n            await this.createQueryBuilder(target)\n              .update({ [idColumn.name]: null, [typeColumn.name]: null })\n              .where({ [idColumn.name]: id, [typeColumn.name]: uid })\n              .transacting(trx)\n              .execute();\n          } else if (\n            targetAttribute.type === 'relation' &&\n            targetAttribute.relation === 'morphToMany'\n          ) {\n            const { joinTable } = targetAttribute;\n            const { morphColumn } = joinTable;\n\n            const { idColumn, typeColumn } = morphColumn;\n\n            await this.createQueryBuilder(joinTable.name)\n              .delete()\n              .where({\n                [idColumn.name]: id,\n                [typeColumn.name]: uid,\n                ...(joinTable.on || {}),\n                field: attributeName,\n              })\n              .transacting(trx)\n              .execute();\n          }\n\n          continue;\n        }\n\n        /*\n          if morphToOne\n            nothing to do\n        */\n        if (attribute.relation === 'morphToOne') {\n          // do nothing\n        }\n\n        /*\n            if morphToMany\n            delete links\n        */\n        if (attribute.relation === 'morphToMany') {\n          const { joinTable } = attribute;\n          const { joinColumn } = joinTable;\n\n          await this.createQueryBuilder(joinTable.name)\n            .delete()\n            .where({\n              [joinColumn.name]: id,\n              ...(joinTable.on || {}),\n            })\n            .transacting(trx)\n            .execute();\n\n          continue;\n        }\n\n        // do not need to delete links when using foreign keys\n        if (db.dialect.usesForeignKeys()) {\n          return;\n        }\n\n        // NOTE: we do not remove existing associations with the target as it should handled by unique FKs instead\n        if ('joinColumn' in attribute && attribute.joinColumn && attribute.owner) {\n          // nothing to do => relation already added on the table\n          continue;\n        }\n\n        // oneToOne oneToMany on the non owning side.\n        if ('joinColumn' in attribute && attribute.joinColumn && !attribute.owner) {\n          // need to set the column on the target\n          const { target } = attribute;\n\n          await this.createQueryBuilder(target)\n            .where({ [attribute.joinColumn.referencedColumn]: id })\n            .update({ [attribute.joinColumn.referencedColumn]: null })\n            .transacting(trx)\n            .execute();\n        }\n\n        if ('joinTable' in attribute && attribute.joinTable) {\n          await deleteRelations({ id, attribute, db, relIdsToDelete: 'all', transaction: trx });\n        }\n      }\n    },\n\n    // TODO: add lifecycle events\n    async populate(uid, entity, populate) {\n      const entry = await this.findOne(uid, {\n        select: ['id'],\n        where: { id: entity.id },\n        populate,\n      });\n\n      return { ...entity, ...entry };\n    },\n\n    // TODO: add lifecycle events\n    async load(uid, entity, fields, populate) {\n      const { attributes } = db.metadata.get(uid);\n\n      const fieldsArr = castArray(fields);\n      fieldsArr.forEach((field) => {\n        const attribute = attributes[field];\n\n        if (!attribute || attribute.type !== 'relation') {\n          throw new Error(`Invalid load. Expected ${field} to be a relational attribute`);\n        }\n      });\n\n      const entry = await this.findOne(uid, {\n        select: ['id'],\n        where: { id: entity.id },\n        populate: fieldsArr.reduce(\n          (acc, field) => {\n            acc[field] = populate || true;\n            return acc;\n          },\n          {} as Record<string, unknown>\n        ),\n      });\n\n      if (!entry) {\n        return null;\n      }\n\n      if (Array.isArray(fields)) {\n        return pick(fields, entry);\n      }\n\n      return entry[fields];\n    },\n\n    // cascading\n    // aggregations\n    // -> avg\n    // -> min\n    // -> max\n    // -> grouping\n\n    // formulas\n    // custom queries\n\n    // utilities\n    // -> map result\n    // -> map input\n\n    // extra features\n    // -> virtuals\n    // -> private\n\n    createQueryBuilder(uid) {\n      return createQueryBuilder(uid, db);\n    },\n\n    getRepository(uid) {\n      if (!repoMap[uid]) {\n        repoMap[uid] = createRepository(uid, db);\n      }\n\n      return repoMap[uid];\n    },\n  };\n};\n"],"names":["isRecord","value","isObject","isNil","toId","isValidId","id","Error","JSON","stringify","toIds","castArray","map","isString","isInteger","isValidObjectId","toIdArray","data","array","filter","datum","__pivot","uniqWith","isEqual","toAssocs","isArray","isNumber","isNull","set","options","strict","connect","elm","position","end","__type","disconnect","processData","metadata","withDefaults","attributes","obj","attributeName","Object","keys","attribute","types","field","createField","isUndefined","default","validate","val","toDB","joinColumn","owner","joinColumnName","name","attrValue","morphColumn","idColumn","typeColumn","typeField","assign","has","createEntityManager","db","repoMap","findOne","uid","params","states","lifecycles","run","result","createQueryBuilder","init","first","execute","findMany","count","res","pick","Number","create","get","isPlainObject","dataToInsert","insert","trx","strapi","transaction","attachRelations","commit","e","rollback","where","delete","select","populate","filters","createMany","isEmpty","createdEntries","length","ids","entry","update","entity","mapResults","dataToUpdate","updateRelations","updateMany","updatedRows","concat","deleteRelations","deleteMany","deletedRows","isValidLink","type","cleanRelationData","relation","target","morphBy","targetAttribute","relId","transacting","joinTable","rows","idx","on","order","dataset","orderMap","relationsOrderer","encodePolymorphicRelation","reduce","acc","rel","forEach","row","rowId","rowType","encodedId","encodePolymorphicId","deleteRelatedMorphOneRelationsAfterMorphToManyUpdate","relIdsToAdd","isBidirectional","$ne","referencedColumn","inverseJoinColumn","orderColumnName","inverseOrderColumnName","relsToAdd","relIdsToadd","isOneToAny","deletePreviousOneToAnyRelations","uniqBy","hasOrderColumn","hasInverseOrderColumn","maxResults","getConnection","max","as","whereIn","groupBy","from","maxMap","hasSet","hasConnect","hasDisconnect","idsToDelete","$or","item","start","startOrder","rowsToDelete","adjacentRelations","$in","compact","r","after","before","getKnexQuery","getOrderMap","push","relIdsToDelete","isPartialUpdate","relIdsToaddOrMove","isAnyToOne","differenceWith","currentMovingRels","relToAdd","nonExistingRelsIds","difference","query","onConflict","pivotColumns","merge","ignore","cleanOrderColumns","slice","relIdsToNotDelete","existingRels","inverseRelsIds","deletePreviousAnyToOneRelations","relIdToadd","dialect","usesForeignKeys","load","fields","fieldsArr","Array","getRepository","createRepository"],"mappings":"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"}