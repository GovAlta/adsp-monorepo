{"version":3,"file":"remove-orphan-morph-types.mjs","sources":["../../../src/repairs/operations/remove-orphan-morph-types.ts"],"sourcesContent":["import type { Database } from '../..';\nimport type { Attribute, MorphRelationalAttribute } from '../../types';\n\nexport interface RemoveOrphanMorphTypeOptions {\n  pivot: string;\n}\n\nconst isMorphRelationWithPivot = (\n  attribute: Attribute,\n  pivot: string\n): attribute is MorphRelationalAttribute => {\n  return (\n    attribute.type === 'relation' &&\n    'relation' in attribute &&\n    'joinTable' in attribute &&\n    'name' in attribute.joinTable &&\n    'pivotColumns' in attribute.joinTable &&\n    attribute.joinTable.pivotColumns.includes(pivot)\n  );\n};\n\nconst filterMorphRelationalAttributes = (\n  attributes: Record<string, Attribute>,\n  pivot: string\n): MorphRelationalAttribute[] => {\n  return Object.values(attributes).filter((attribute): attribute is MorphRelationalAttribute =>\n    isMorphRelationWithPivot(attribute, pivot)\n  );\n};\n\n/**\n * Removes morph relation data with invalid or non-existent morph type.\n *\n * This function iterates over the database metadata to identify morph relationships\n * (relations with a `joinTable` containing the specified pivot column) and removes\n * any entries in the relation's join table where the morph type is invalid.\n *\n * Note: This function does not check for orphaned IDs, only orphaned morph types.\n *\n * @param db - The database object containing metadata and a Knex connection.\n * @param options.pivot - The name of the column in the join table representing the morph type.\n */\nexport const removeOrphanMorphType = async (\n  db: Database,\n  { pivot }: RemoveOrphanMorphTypeOptions\n) => {\n  db.logger.debug(`Removing orphaned morph type: ${JSON.stringify(pivot)}`);\n\n  const mdValues = db.metadata.values();\n  for (const model of mdValues) {\n    const attributes = filterMorphRelationalAttributes(model.attributes || {}, pivot);\n\n    for (const attribute of attributes) {\n      const joinTableName = attribute.joinTable.name;\n\n      // Query distinct morph types from the join table\n      const morphTypes = await db.connection(joinTableName).distinct(pivot).pluck(pivot);\n\n      for (const morphType of morphTypes) {\n        // Check if metadata for the morph type exists\n        const deleteComponentType = await (async () => {\n          try {\n            return !db.metadata.get(morphType); // If no metadata found, mark for deletion\n          } catch {\n            db.logger.debug(\n              `Metadata for morph type \"${morphType}\" in table \"${joinTableName}\" not found`\n            );\n            return true; // Return true to delete if metadata is missing\n          }\n        })();\n\n        if (deleteComponentType) {\n          db.logger.debug(\n            `Removing invalid morph type \"${morphType}\" from table \"${joinTableName}\".`\n          );\n          try {\n            await db.connection(joinTableName).where(pivot, morphType).del();\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            db.logger.error(\n              `Failed to remove invalid morph type \"${morphType}\" from table \"${joinTableName}\": ${errorMessage}`\n            );\n          }\n        }\n      }\n    }\n  }\n};\n"],"names":["isMorphRelationWithPivot","attribute","pivot","type","joinTable","pivotColumns","includes","filterMorphRelationalAttributes","attributes","Object","values","filter","removeOrphanMorphType","db","logger","debug","JSON","stringify","mdValues","metadata","model","joinTableName","name","morphTypes","connection","distinct","pluck","morphType","deleteComponentType","get","where","del","error","errorMessage","Error","message","String"],"mappings":"AAOA,MAAMA,wBAAAA,GAA2B,CAC/BC,SACAC,EAAAA,KAAAA,GAAAA;IAEA,OACED,SAAAA,CAAUE,IAAI,KAAK,UAAA,IACnB,cAAcF,SACd,IAAA,WAAA,IAAeA,SACf,IAAA,MAAA,IAAUA,SAAUG,CAAAA,SAAS,IAC7B,cAAkBH,IAAAA,SAAAA,CAAUG,SAAS,IACrCH,SAAAA,CAAUG,SAAS,CAACC,YAAY,CAACC,QAAQ,CAACJ,KAAAA,CAAAA;AAE9C,CAAA;AAEA,MAAMK,+BAAAA,GAAkC,CACtCC,UACAN,EAAAA,KAAAA,GAAAA;IAEA,OAAOO,MAAAA,CAAOC,MAAM,CAACF,UAAAA,CAAAA,CAAYG,MAAM,CAAC,CAACV,SACvCD,GAAAA,wBAAAA,CAAyBC,SAAWC,EAAAA,KAAAA,CAAAA,CAAAA;AAExC,CAAA;AAEA;;;;;;;;;;;AAWC,IACYU,MAAAA,qBAAAA,GAAwB,OACnCC,EACA,EAAA,EAAEX,KAAK,EAAgC,GAAA;IAEvCW,EAAGC,CAAAA,MAAM,CAACC,KAAK,CAAC,CAAC,8BAA8B,EAAEC,IAAKC,CAAAA,SAAS,CAACf,KAAAA,CAAAA,CAAO,CAAC,CAAA;AAExE,IAAA,MAAMgB,QAAWL,GAAAA,EAAAA,CAAGM,QAAQ,CAACT,MAAM,EAAA;IACnC,KAAK,MAAMU,SAASF,QAAU,CAAA;AAC5B,QAAA,MAAMV,aAAaD,+BAAgCa,CAAAA,KAAAA,CAAMZ,UAAU,IAAI,EAAIN,EAAAA,KAAAA,CAAAA;QAE3E,KAAK,MAAMD,aAAaO,UAAY,CAAA;AAClC,YAAA,MAAMa,aAAgBpB,GAAAA,SAAAA,CAAUG,SAAS,CAACkB,IAAI;;YAG9C,MAAMC,UAAAA,GAAa,MAAMV,EAAAA,CAAGW,UAAU,CAACH,eAAeI,QAAQ,CAACvB,KAAOwB,CAAAA,CAAAA,KAAK,CAACxB,KAAAA,CAAAA;YAE5E,KAAK,MAAMyB,aAAaJ,UAAY,CAAA;;gBAElC,MAAMK,mBAAAA,GAAsB,MAAO,CAAA,UAAA;oBACjC,IAAI;AACF,wBAAA,OAAO,CAACf,EAAGM,CAAAA,QAAQ,CAACU,GAAG,CAACF;AAC1B,qBAAA,CAAE,OAAM;AACNd,wBAAAA,EAAAA,CAAGC,MAAM,CAACC,KAAK,CACb,CAAC,yBAAyB,EAAEY,SAAAA,CAAU,YAAY,EAAEN,aAAc,CAAA,WAAW,CAAC,CAAA;AAEhF,wBAAA,OAAO;AACT;iBACF,GAAA;AAEA,gBAAA,IAAIO,mBAAqB,EAAA;AACvBf,oBAAAA,EAAAA,CAAGC,MAAM,CAACC,KAAK,CACb,CAAC,6BAA6B,EAAEY,SAAAA,CAAU,cAAc,EAAEN,aAAc,CAAA,EAAE,CAAC,CAAA;oBAE7E,IAAI;wBACF,MAAMR,EAAAA,CAAGW,UAAU,CAACH,aAAAA,CAAAA,CAAeS,KAAK,CAAC5B,KAAAA,EAAOyB,WAAWI,GAAG,EAAA;AAChE,qBAAA,CAAE,OAAOC,KAAO,EAAA;AACd,wBAAA,MAAMC,eAAeD,KAAiBE,YAAAA,KAAAA,GAAQF,KAAMG,CAAAA,OAAO,GAAGC,MAAOJ,CAAAA,KAAAA,CAAAA;AACrEnB,wBAAAA,EAAAA,CAAGC,MAAM,CAACkB,KAAK,CACb,CAAC,qCAAqC,EAAEL,SAAU,CAAA,cAAc,EAAEN,aAAAA,CAAc,GAAG,EAAEY,aAAa,CAAC,CAAA;AAEvG;AACF;AACF;AACF;AACF;AACF;;;;"}