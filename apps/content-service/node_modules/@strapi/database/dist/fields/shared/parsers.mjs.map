{"version":3,"file":"parsers.mjs","sources":["../../../src/fields/shared/parsers.ts"],"sourcesContent":["import { padCharsEnd, isString, toString } from 'lodash/fp';\nimport * as dateFns from 'date-fns';\n\nimport { InvalidDateTimeError, InvalidDateError, InvalidTimeError } from '../../errors';\n\nconst isDate = (value: unknown): value is Date => {\n  return dateFns.isDate(value);\n};\n\nconst DATE_REGEX = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\nconst PARTIAL_DATE_REGEX = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])/g;\nconst TIME_REGEX = /^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]{1,3})?$/;\n\nexport const parseDateTimeOrTimestamp = (value: unknown): Date => {\n  if (isDate(value)) {\n    return value;\n  }\n\n  try {\n    const date = dateFns.parseISO(toString(value));\n    if (dateFns.isValid(date)) {\n      return date;\n    }\n\n    const milliUnixDate = dateFns.parse(toString(value), 'T', new Date());\n    if (dateFns.isValid(milliUnixDate)) {\n      return milliUnixDate;\n    }\n\n    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);\n  } catch (error) {\n    throw new InvalidDateTimeError(`Invalid format, expected a timestamp or an ISO date`);\n  }\n};\n\nexport const parseDate = (value: unknown) => {\n  if (isDate(value)) {\n    return dateFns.format(value, 'yyyy-MM-dd');\n  }\n\n  const found = isString(value) ? value.match(PARTIAL_DATE_REGEX) || [] : [];\n  const extractedValue = found[0];\n\n  if (extractedValue && !DATE_REGEX.test(toString(value))) {\n    // TODO V5: throw an error when format yyyy-MM-dd is not respected\n    // throw new InvalidDateError(`Invalid format, expected yyyy-MM-dd`);\n    process.emitWarning(\n      `[deprecated] Using a date format other than YYYY-MM-DD will be removed in future versions. Date received: ${value}. Date stored: ${extractedValue}.`\n    );\n  }\n\n  if (!extractedValue) {\n    throw new InvalidDateError(`Invalid format, expected yyyy-MM-dd`);\n  }\n\n  const date = dateFns.parseISO(extractedValue);\n  if (!dateFns.isValid(date)) {\n    throw new InvalidDateError(`Invalid date`);\n  }\n\n  return extractedValue;\n};\n\nexport const parseTime = (value: unknown) => {\n  if (isDate(value)) {\n    return dateFns.format(value, 'HH:mm:ss.SSS');\n  }\n\n  if (typeof value !== 'string') {\n    throw new InvalidTimeError(`Expected a string, got a ${typeof value}`);\n  }\n\n  const result = value.match(TIME_REGEX);\n\n  if (result === null) {\n    throw new InvalidTimeError('Invalid time format, expected HH:mm:ss.SSS');\n  }\n\n  const [, hours, minutes, seconds, fraction = '.000'] = result;\n  const fractionPart = padCharsEnd('0', 3, fraction.slice(1));\n\n  return `${hours}:${minutes}:${seconds}.${fractionPart}`;\n};\n"],"names":["isDate","value","dateFns","DATE_REGEX","PARTIAL_DATE_REGEX","TIME_REGEX","parseDateTimeOrTimestamp","date","parseISO","toString","isValid","milliUnixDate","parse","Date","InvalidDateTimeError","error","parseDate","format","found","isString","match","extractedValue","test","process","emitWarning","InvalidDateError","parseTime","InvalidTimeError","result","hours","minutes","seconds","fraction","fractionPart","padCharsEnd","slice"],"mappings":"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"}