{"version":3,"file":"process.js","sources":["../../../../src/query/helpers/populate/process.ts"],"sourcesContent":["import _ from 'lodash/fp';\n\nimport * as types from '../../../utils/types';\nimport type { Meta } from '../../../metadata';\nimport type { QueryBuilder } from '../../query-builder';\nimport type { Database } from '../../..';\n\nconst getRootLevelPopulate = (meta: Meta) => {\n  const populate: PopulateMap = {};\n\n  for (const attributeName of Object.keys(meta.attributes)) {\n    const attribute = meta.attributes[attributeName];\n    if (attribute.type === 'relation') {\n      populate[attributeName] = true;\n    }\n  }\n\n  return populate;\n};\n\ntype Context = {\n  qb: QueryBuilder;\n  db: Database;\n  uid: string;\n};\n\ntype PopulateMap = {\n  [key: string]:\n    | true\n    | {\n        populate?: PopulateMap | true | string[];\n      };\n};\n\n/**\n * Converts and prepares the query for populate\n *\n * @param {boolean|string[]|object} populate populate param\n * @param {object} ctx query context\n * @param {object} ctx.db database instance\n * @param {object} ctx.qb query builder instance\n * @param {string} ctx.uid model uid\n */\nconst processPopulate = (populate: unknown, ctx: Context) => {\n  const { qb, db, uid } = ctx;\n  const meta = db.metadata.get(uid);\n\n  let populateMap: PopulateMap = {};\n\n  if (populate === false || _.isNil(populate)) {\n    return null;\n  }\n\n  if (populate === true) {\n    populateMap = getRootLevelPopulate(meta);\n  } else if (Array.isArray(populate)) {\n    for (const key of populate) {\n      const [root, ...rest] = key.split('.');\n\n      if (rest.length > 0) {\n        const subPopulate = rest.join('.');\n        if (populateMap[root]) {\n          const populateValue = populateMap[root];\n\n          if (populateValue === true) {\n            populateMap[root] = {\n              populate: [subPopulate],\n            };\n          } else {\n            populateValue.populate = [subPopulate].concat(populateValue.populate ?? []);\n          }\n        } else {\n          populateMap[root] = {\n            populate: [subPopulate],\n          };\n        }\n      } else {\n        populateMap[root] = populateMap[root] ? populateMap[root] : true;\n      }\n    }\n  } else {\n    populateMap = populate as PopulateMap;\n  }\n\n  if (!_.isPlainObject(populateMap)) {\n    throw new Error('Populate must be an object');\n  }\n\n  const finalPopulate: PopulateMap = {};\n  for (const key of Object.keys(populateMap)) {\n    const attribute = meta.attributes[key];\n\n    if (!attribute) {\n      continue;\n    }\n\n    if (!types.isRelation(attribute.type)) {\n      continue;\n    }\n\n    // Make sure to query the join column value if needed,\n    // so that we can apply the populate later on\n    if ('joinColumn' in attribute && attribute.joinColumn) {\n      qb.addSelect(attribute.joinColumn.name);\n    }\n\n    // Make sure id is present for future populate queries\n    if (_.has('id', meta.attributes)) {\n      qb.addSelect('id');\n    }\n\n    finalPopulate[key] = populateMap[key];\n  }\n\n  return finalPopulate;\n};\n\nexport default processPopulate;\n"],"names":["getRootLevelPopulate","meta","populate","attributeName","Object","keys","attributes","attribute","type","processPopulate","ctx","qb","db","uid","metadata","get","populateMap","_","isNil","Array","isArray","key","root","rest","split","length","subPopulate","join","populateValue","concat","isPlainObject","Error","finalPopulate","types","joinColumn","addSelect","name","has"],"mappings":"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"}