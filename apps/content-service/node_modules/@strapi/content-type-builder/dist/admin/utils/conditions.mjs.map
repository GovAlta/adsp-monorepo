{"version":3,"file":"conditions.mjs","sources":["../../../admin/src/utils/conditions.ts"],"sourcesContent":["import type { AnyAttribute } from '../types';\n\ninterface DependentRow {\n  contentTypeUid: string;\n  contentType: string;\n  attribute: string;\n}\n\nexport const checkDependentRows = (\n  contentTypes: Record<string, any>,\n  fieldName: string\n): DependentRow[] => {\n  const dependentRows: DependentRow[] = [];\n\n  Object.entries(contentTypes).forEach(([contentTypeUid, contentType]: [string, any]) => {\n    if (contentType.attributes) {\n      // Handle both array and object formats of attributes\n      const attributes = Array.isArray(contentType.attributes)\n        ? contentType.attributes.reduce((acc: Record<string, any>, attr: any, index: number) => {\n            acc[index.toString()] = attr;\n            return acc;\n          }, {})\n        : contentType.attributes;\n\n      Object.entries(attributes).forEach(([attrName, attr]: [string, any]) => {\n        if (attr.conditions?.visible) {\n          Object.entries(attr.conditions.visible).forEach(([, conditions]) => {\n            const [fieldVar] = conditions as [{ var: string }, any];\n            // Check if this condition references our field\n            if (fieldVar && fieldVar.var === fieldName) {\n              dependentRows.push({\n                contentTypeUid,\n                contentType: contentType.info.displayName,\n                attribute: attr.name || attrName,\n              });\n            }\n          });\n        }\n      });\n    }\n  });\n  return dependentRows;\n};\n\nexport const formatCondition = (\n  condition: any,\n  availableFields: Array<{ name: string; type: string }>,\n  attributeName: string\n): string => {\n  if (!condition?.visible) {\n    return '';\n  }\n\n  const [[operator, conditions]] = Object.entries(condition.visible);\n  const [fieldVar, value] = conditions as [{ var: string }, any];\n\n  const dependsOnField = availableFields.find((field) => field.name === fieldVar.var);\n  const dependsOnFieldName = dependsOnField ? dependsOnField.name : fieldVar.var;\n\n  const operatorText = operator === '==' ? 'is' : 'is not';\n  const valueText = String(value);\n  const actionText = operator === '==' ? 'Show' : 'Hide';\n\n  return `If ${dependsOnFieldName} ${operatorText} ${valueText}, then ${actionText} ${attributeName}`;\n};\n\nexport const getAvailableConditionFields = (\n  attributes: AnyAttribute[],\n  currentFieldName: string\n) => {\n  return attributes\n    .filter((attr) => {\n      // Only include boolean and enum fields\n      const isCorrectType = attr.type === 'boolean' || attr.type === 'enumeration';\n      // Exclude the current field to prevent self-referential conditions\n      const isNotCurrentField = attr.name !== currentFieldName;\n      return isCorrectType && isNotCurrentField;\n    })\n    .map((attr) => ({\n      name: attr.name,\n      type: attr.type,\n      enum: attr.type === 'enumeration' ? attr.enum : undefined,\n    }));\n};\n"],"names":["checkDependentRows","contentTypes","fieldName","dependentRows","Object","entries","forEach","contentTypeUid","contentType","attributes","Array","isArray","reduce","acc","attr","index","toString","attrName","conditions","visible","fieldVar","var","push","info","displayName","attribute","name","formatCondition","condition","availableFields","attributeName","operator","value","dependsOnField","find","field","dependsOnFieldName","operatorText","valueText","String","actionText","getAvailableConditionFields","currentFieldName","filter","isCorrectType","type","isNotCurrentField","map","enum","undefined"],"mappings":"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"}