"use strict";
var _TenantKeyProvider_clientCache, _TenantKeyProvider_createJwksClient;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TenantKeyProvider = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const NodeCache = require("node-cache");
const jwks_rsa_1 = require("jwks-rsa");
const jwt_decode_1 = require("jwt-decode");
class TenantKeyProvider {
    constructor(logger, accessServiceUrl, issuerCache) {
        this.logger = logger;
        this.accessServiceUrl = accessServiceUrl;
        this.issuerCache = issuerCache;
        this.LOG_CONTEXT = { context: 'TenantKeyProvider' };
        _TenantKeyProvider_clientCache.set(this, new NodeCache({
            stdTTL: 36000,
            useClones: false,
        }));
        _TenantKeyProvider_createJwksClient.set(this, (iss) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Creating JWKS client for iss '${iss}'...'`, this.LOG_CONTEXT);
            const tenant = yield this.issuerCache.getTenantByIssuer(iss);
            if (!tenant) {
                throw new Error(`Cannot find tenant associated with iss: ${iss}`);
            }
            else {
                const oidcUrl = new URL(`/auth/realms/${tenant.realm}/.well-known/openid-configuration`, this.accessServiceUrl);
                const { data } = yield axios_1.default.get(oidcUrl.href);
                if (data.issuer !== iss) {
                    throw new Error(`Tenant '${tenant.id}' realm '${tenant.realm}' openid-configuration response not consistent with token iss value.`);
                }
                const client = new jwks_rsa_1.JwksClient({
                    jwksUri: data.jwks_uri,
                    cache: true,
                });
                tslib_1.__classPrivateFieldGet(this, _TenantKeyProvider_clientCache, "f").set(iss, client);
                this.logger.info(`Created and cached JWKS client for iss '${iss}'.'`, this.LOG_CONTEXT);
                return client;
            }
        }));
        this.keyRequestHandler = (_req, token, done) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { kid } = (0, jwt_decode_1.default)(token, { header: true });
                const { iss } = (0, jwt_decode_1.default)(token);
                this.logger.debug(`Decoded JWT from request with iss '${iss}' and kid '${kid}'...`, this.LOG_CONTEXT);
                const client = tslib_1.__classPrivateFieldGet(this, _TenantKeyProvider_clientCache, "f").get(iss) || (yield tslib_1.__classPrivateFieldGet(this, _TenantKeyProvider_createJwksClient, "f").call(this, iss));
                this.logger.debug(`Retrieving public key from JWKS client...'`, this.LOG_CONTEXT);
                client.getSigningKey(kid, (err, key) => {
                    if (err) {
                        this.logger.error(`Error encountered in request to JWKS client. ${err}`, this.LOG_CONTEXT);
                    }
                    done(err, key === null || key === void 0 ? void 0 : key.getPublicKey());
                });
            }
            catch (err) {
                this.logger.error(`Error encountered verifying token signature. ${err}`);
                done(err);
            }
        });
    }
}
exports.TenantKeyProvider = TenantKeyProvider;
_TenantKeyProvider_clientCache = new WeakMap(), _TenantKeyProvider_createJwksClient = new WeakMap();
//# sourceMappingURL=keyProvider.js.map