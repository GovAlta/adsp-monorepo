"use strict";
var _ConfigurationServiceImpl_configuration, _ConfigurationServiceImpl_converter, _ConfigurationServiceImpl_combine;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationServiceImpl = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const moize_1 = require("moize");
const NodeCache = require("node-cache");
const utils_1 = require("../utils");
class ConfigurationServiceImpl {
    constructor(serviceId, logger, directory, tokenProvider, useNamespace = false, converter = null, combine = null, cacheTTL = 900) {
        this.serviceId = serviceId;
        this.logger = logger;
        this.directory = directory;
        this.tokenProvider = tokenProvider;
        this.useNamespace = useNamespace;
        this.LOG_CONTEXT = { context: 'ConfigurationService' };
        _ConfigurationServiceImpl_configuration.set(this, void 0);
        _ConfigurationServiceImpl_converter.set(this, (value) => value);
        _ConfigurationServiceImpl_combine.set(this, (tenantConfig, coreConfig) => [tenantConfig, coreConfig]);
        this.getConfiguration = (serviceId, token, tenantId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { namespace, service: name } = serviceId;
            let tenantConfiguration = null;
            if (tenantId) {
                (0, utils_1.assertAdspId)(tenantId, 'Provided ID is not for a tenant', 'resource');
                tenantConfiguration = yield this.getConfigurationFromCacheOrApi(namespace, name, token, tenantId);
            }
            const coreConfiguration = yield this.getConfigurationFromCacheOrApi(namespace, name, token);
            return tslib_1.__classPrivateFieldGet(this, _ConfigurationServiceImpl_combine, "f").call(this, tenantConfiguration, coreConfiguration, tenantId);
        });
        this.getServiceConfiguration = (name, tenantId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If the service uses its own namespace for configuration, then service name (e.g. task-service) is the namespace,
            // otherwise the namespace of the service (e.g. platform) is used.
            const namespace = this.useNamespace ? this.serviceId.service : this.serviceId.namespace;
            // If the service uses its own namespace for configuration, then name input param is required,
            // otherwise the service name (e.g. task-service) is used.
            name = this.useNamespace ? name : this.serviceId.service;
            if (!name) {
                throw new Error('Name must be specified if useNamespace is true and service has configuration across a namespace.');
            }
            const token = yield this.tokenProvider.getAccessToken();
            let tenantConfiguration = null;
            if (tenantId) {
                (0, utils_1.assertAdspId)(tenantId, 'Provided ID is not for a tenant', 'resource');
                tenantConfiguration = yield this.getConfigurationFromCacheOrApi(namespace, name, token, tenantId, true);
            }
            const coreConfiguration = yield this.getConfigurationFromCacheOrApi(namespace, name, token, null, true);
            return tslib_1.__classPrivateFieldGet(this, _ConfigurationServiceImpl_combine, "f").call(this, tenantConfiguration, coreConfiguration, tenantId);
        });
        tslib_1.__classPrivateFieldSet(this, _ConfigurationServiceImpl_configuration, new NodeCache({
            stdTTL: cacheTTL,
            useClones: false,
        }), "f");
        if (converter) {
            tslib_1.__classPrivateFieldSet(this, _ConfigurationServiceImpl_converter, converter, "f");
        }
        if (combine) {
            // Memoize the combine function in case it is expensive.
            // Note: we might be better served by just caching the combined result in node cache, but for now the tenant
            // and core configuration retrievals are independent requests.
            tslib_1.__classPrivateFieldSet(this, _ConfigurationServiceImpl_combine, (0, moize_1.default)(combine, {
                maxSize: 50,
                matchesArg: (a, b) => {
                    if (a instanceof utils_1.AdspId && b instanceof utils_1.AdspId) {
                        return a.toString() === b.toString();
                    }
                    else {
                        return a === b;
                    }
                },
            }), "f");
        }
    }
    getCacheKey(namespace, name, tenantId) {
        return `${tenantId ? tenantId.toString() + '-' : ''}${namespace}:${name}`;
    }
    retrieveConfiguration(namespace, name, token, tenantId, useActive) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Retrieving (${(tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString()) || 'core'}) configuration for ${namespace}${name}...'`, Object.assign(Object.assign({}, this.LOG_CONTEXT), { tenant: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString() }));
            const configurationServiceUrl = yield this.directory.getServiceUrl((0, utils_1.adspId) `urn:ads:platform:configuration-service:v2`);
            const configUrl = useActive
                ? new URL(`v2/configuration/${namespace}/${name}/active`, configurationServiceUrl)
                : new URL(`v2/configuration/${namespace}/${name}/latest`, configurationServiceUrl);
            this.logger.debug(`Retrieving configuration from ${configUrl}...'`, Object.assign(Object.assign({}, this.LOG_CONTEXT), { tenant: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString() }));
            try {
                let { data } = yield axios_1.default.get(configUrl.href, {
                    headers: { Authorization: `Bearer ${token}` },
                    params: {
                        tenantId: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString(),
                        orLatest: useActive || undefined,
                    },
                });
                // Active endpoint returns the revision instead of just the raw configuration value.
                if (useActive) {
                    data = data === null || data === void 0 ? void 0 : data.configuration;
                }
                const config = (data ? tslib_1.__classPrivateFieldGet(this, _ConfigurationServiceImpl_converter, "f").call(this, data, tenantId) : null);
                if (config) {
                    tslib_1.__classPrivateFieldGet(this, _ConfigurationServiceImpl_configuration, "f").set(this.getCacheKey(namespace, name, tenantId), config);
                    this.logger.info(`Retrieved and cached (${(tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString()) || 'core'}) configuration for ${namespace}:${name}.`, Object.assign(Object.assign({}, this.LOG_CONTEXT), { tenant: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString() }));
                }
                else {
                    // Cache a null to prevent API request every time.
                    tslib_1.__classPrivateFieldGet(this, _ConfigurationServiceImpl_configuration, "f").set(this.getCacheKey(namespace, name, tenantId), null);
                    this.logger.info(`Retrieved configuration for ${namespace}:${name} and received no value.`, Object.assign(Object.assign({}, this.LOG_CONTEXT), { tenant: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString() }));
                }
                return config;
            }
            catch (err) {
                this.logger.warn(`Error encountered in request for configuration of ${namespace}:${name}. ${err}`, Object.assign(Object.assign({}, this.LOG_CONTEXT), { tenant: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString() }));
                return null;
            }
        });
    }
    getConfigurationFromCacheOrApi(namespace_1, name_1, token_1, tenantId_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (namespace, name, token, tenantId, useActive = false) {
            let configuration = tslib_1.__classPrivateFieldGet(this, _ConfigurationServiceImpl_configuration, "f").get(this.getCacheKey(namespace, name, tenantId));
            if (configuration === undefined) {
                configuration = (yield this.retrieveConfiguration(namespace, name, token, tenantId, useActive)) || null;
            }
            else {
                this.logger.debug(`Configuration (${(tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString()) || 'core'}) ${namespace}:${name} retrieved from cache.`, Object.assign(Object.assign({}, this.LOG_CONTEXT), { tenant: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString() }));
            }
            return configuration;
        });
    }
    clearCached(tenantId, namespace, name) {
        if (tslib_1.__classPrivateFieldGet(this, _ConfigurationServiceImpl_configuration, "f").del(this.getCacheKey(namespace, name, tenantId)) > 0) {
            this.logger.info(`Cleared cached configuration for ${namespace}:${name} of tenant ${tenantId}.`, Object.assign(Object.assign({}, this.LOG_CONTEXT), { tenant: tenantId === null || tenantId === void 0 ? void 0 : tenantId.toString() }));
        }
    }
}
exports.ConfigurationServiceImpl = ConfigurationServiceImpl;
_ConfigurationServiceImpl_configuration = new WeakMap(), _ConfigurationServiceImpl_converter = new WeakMap(), _ConfigurationServiceImpl_combine = new WeakMap();
tslib_1.__decorate([
    (0, utils_1.LimitToOne)((propertyKey, namespace, name, _token, tenantId) => `${propertyKey}-${tenantId ? `${tenantId}-` : ''}${namespace}:${name}`),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, String, utils_1.AdspId, Boolean]),
    tslib_1.__metadata("design:returntype", Promise)
], ConfigurationServiceImpl.prototype, "retrieveConfiguration", null);
//# sourceMappingURL=configurationService.js.map