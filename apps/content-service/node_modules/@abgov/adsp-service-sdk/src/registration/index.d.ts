import { Logger } from 'winston';
import { NotificationType } from '..';
import { TokenProvider } from '../access';
import { ServiceDirectory } from '../directory';
import { DomainEventDefinition } from '../event';
import { FileType } from '../file';
import { Stream } from '../push';
import { AdspId } from '../utils';
import { ValueDefinition } from '../value';
export interface ServiceRole {
    /**
     * Name of the role.
     *
     * @type {string}
     * @memberof ServiceRole
     */
    role: string;
    /**
     * Description of the role.
     *
     * @type {string}
     * @memberof ServiceRole
     */
    description: string;
    /**
     * Flag indicating if the role should be part of the tenant admin composite role.
     * If true tenant administrators will have permissions associated with this role.
     *
     * @type {boolean}
     * @memberof ServiceRole
     */
    inTenantAdmin?: boolean;
}
interface ConfigurationRegistrationOptions {
    /**
     * JSON schema of the configuration.
     *
     * @type {Record<string, unknown>}
     * @memberof ConfigurationRegistrationOptions
     */
    schema: Record<string, unknown>;
    /**
     * Description of the configuration.
     *
     * @type {string}
     * @memberof ConfigurationRegistrationOptions
     */
    description: string;
    /**
     * Flag indicating if the service uses a full namespace for configuration.
     * If false the service configuration is a single document stored under [service namespace]:[service name];
     * otherwise the service can have many configuration at different names under [service name]:[configuration name].
     *
     * @type {boolean}
     * @memberof ConfigurationRegistrationOptions
     */
    useNamespace?: boolean;
}
export interface ServiceRegistration {
    /**
     * Service ID: ADSP ID of the service.
     *
     * The service ID is an ADSP URN that uniquely identifies the service being registered.
     * Associated configuration will be stored against the namespace and service in the URN.
     *
     * This value is also used as the client ID for the service.
     *
     * @type {AdspId}
     * @memberof ServiceRegistration
     */
    serviceId: AdspId;
    /**
     * Display name: Human friendly name for the service.
     *
     * @type {string}
     * @memberof ServiceRegistration
     */
    displayName: string;
    /**
     * Description: Description of the service.
     *
     * @type {string}
     * @memberof ServiceRegistration
     */
    description: string;
    /**
     * Roles: Service roles that control access into the service capabilities.
     *
     * For platform services, these roles are automatically created under the service client
     * when a new tenant is created.
     *
     * @type {((string | ServiceRole)[])}
     * @memberof ServiceRegistration
     */
    roles?: (string | ServiceRole)[];
    /**
     * @deprecated
     * Configuration schema: JSON schema for configuration of the service.
     *
     * The configuration schema provides a write schema for service configuration in the
     * configuration service. Service associated configuration is stored at namespace and
     * (service) name.
     *
     * @type {Record<string, unknown>}
     * @memberof ServiceRegistration
     */
    configurationSchema?: Record<string, unknown>;
    /**
     * Configuration: JSON schema for configuration of the service and associated description.
     *
     * The configuration provides a schema and a description of the schema. The schema provides a write schema for service configuration in the
     * configuration service. Service associated configuration is stored at namespace and
     * (service) name.
     *
     * @type {schema: Record<string, unknown>, description: string}
     * @memberof ServiceRegistration
     */
    configuration?: ConfigurationRegistrationOptions;
    /**
     * Events: Definitions of domain events of the service.
     *
     * Domain events represent domain significant occurrences like state transitions.
     * Events are recorded to the event log and can trigger side effects such as notifications.
     *
     * @type {DomainEventDefinition[]}
     * @memberof ServiceRegistration
     */
    events?: DomainEventDefinition[];
    /**
     * Event streams: Push mode event streams of the service.
     *
     * Streams make sets of events available over push mode endpoints in push service.
     * Clients can connect to streams over socket.io or Server side events (SSE).
     *
     * @type {Stream[]}
     * @memberof ServiceRegistration
     */
    eventStreams?: Stream[];
    /**
     * File types: File types of the service.
     *
     * File types represent sets of files with specific access rules; i.e. the roles allowed to
     * upload and download the files of the type.
     *
     * @type {FileType[]}
     * @memberof ServiceRegistration
     */
    fileTypes?: FileType[];
    /**
     * Notifications: Subscribable notification types of the service.
     *
     * Notification types represent subscribable collection of notifications. Each type can include
     * multiple notifications with their own templates and triggered by specific events.
     *
     * @type {NotificationType[]}
     * @memberof ServiceRegistration
     */
    notifications?: NotificationType[];
    /**
     * Values: Definitions of time-series values of the service.
     *
     * @type {ValueDefinition[]}
     * @memberof ServiceRegistration
     */
    values?: ValueDefinition[];
    /**
     * Service configurations: Additional configurations for services to apply at registration.
     *
     * This property can be used to configuration services without a defined registration property.
     * Configuration for each entry is applied to the configuration service at the namespace and
     * (service) name.
     *
     * @type {{ serviceId: AdspId; configuration: Record<string, unknown> }[]}
     * @memberof ServiceRegistration
     */
    serviceConfigurations?: {
        serviceId: AdspId;
        configuration: Record<string, unknown>;
    }[];
}
interface ServiceRegistrarOptions {
    logger: Logger;
    directory: ServiceDirectory;
    tokenProvider: TokenProvider;
}
export interface ServiceRegistrar {
    register(registration: ServiceRegistration): Promise<void>;
}
export declare const createServiceRegistrar: ({ logger, directory, tokenProvider, }: ServiceRegistrarOptions) => ServiceRegistrar;
export {};
