"use strict";
var _ServiceDirectoryImpl_directoryCache, _ServiceDirectoryImpl_getOverrideEnv, _ServiceDirectoryImpl_tryRetrieveDirectory;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceDirectoryImpl = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const NodeCache = require("node-cache");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const retry = require('promise-retry');
const utils_1 = require("../utils");
class ServiceDirectoryImpl {
    constructor(logger, directoryUrl) {
        this.logger = logger;
        this.directoryUrl = directoryUrl;
        this.LOG_CONTEXT = { context: 'ServiceDirectory' };
        _ServiceDirectoryImpl_directoryCache.set(this, new NodeCache({
            stdTTL: 36000,
            useClones: false,
        }));
        _ServiceDirectoryImpl_getOverrideEnv.set(this, (urn) => {
            var _a;
            try {
                const entryId = utils_1.AdspId.parse(urn);
                (0, utils_1.assertAdspId)(entryId, 'Directory entry must be a service or API.', 'service', 'api');
                const namespace = entryId.namespace.toUpperCase().replace(/[ -]/g, '_');
                const service = entryId.service.toUpperCase().replace(/[ -]/g, '_');
                const api = (_a = entryId.api) === null || _a === void 0 ? void 0 : _a.toUpperCase().replace(/[ -]/g, '_');
                return `DIR_${namespace}_${service}${api ? `_${api}` : ''}`;
            }
            catch (err) {
                this.logger.debug(`Error resolving override env variable name for: ${urn}`, this.LOG_CONTEXT);
            }
        });
        _ServiceDirectoryImpl_tryRetrieveDirectory.set(this, (requestUrl, count) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Try ${count}: retrieve directory entries...`, this.LOG_CONTEXT);
            const { data } = yield axios_1.default.get(requestUrl.href);
            return data
                .map(({ urn, url }) => {
                let serviceUrl = null;
                try {
                    const overrideEnv = tslib_1.__classPrivateFieldGet(this, _ServiceDirectoryImpl_getOverrideEnv, "f").call(this, urn);
                    const override = process.env[overrideEnv];
                    if (override) {
                        this.logger.info(`Overrode entry ${urn} with value from env variable ${overrideEnv}: ${override}`, this.LOG_CONTEXT);
                        url = override;
                    }
                    serviceUrl = new URL(url);
                    this.logger.debug(`Cached service directory entry ${urn} -> ${serviceUrl}`, this.LOG_CONTEXT);
                }
                catch (err) {
                    this.logger.error(`Error encountered caching entry '${urn}'; entry url may be invalid: ${url}`, this.LOG_CONTEXT);
                }
                return { urn, serviceUrl };
            })
                .filter(({ serviceUrl }) => serviceUrl);
        }));
    }
    retrieveDirectory(namespace) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const url = new URL(`/directory/v2/namespaces/${namespace}/entries`, this.directoryUrl);
            try {
                const results = yield retry((next, count) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield tslib_1.__classPrivateFieldGet(this, _ServiceDirectoryImpl_tryRetrieveDirectory, "f").call(this, url, count);
                    }
                    catch (err) {
                        this.logger.debug(`Try ${count} failed with error. ${err}`, this.LOG_CONTEXT);
                        next(err);
                    }
                }));
                results.forEach(({ urn, serviceUrl }) => {
                    tslib_1.__classPrivateFieldGet(this, _ServiceDirectoryImpl_directoryCache, "f").set(urn, serviceUrl);
                });
                this.logger.info(`Retrieved service directory from ${url}.`, this.LOG_CONTEXT);
            }
            catch (err) {
                this.logger.error(`Error encountered retrieving directory. ${err}`, this.LOG_CONTEXT);
            }
        });
    }
    getServiceUrl(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            (0, utils_1.assertAdspId)(id, 'Provided ID is not for a Service or API.', 'api', 'service');
            const key = `${id}`;
            let value = tslib_1.__classPrivateFieldGet(this, _ServiceDirectoryImpl_directoryCache, "f").get(key);
            if (!value) {
                yield this.retrieveDirectory(id.namespace);
                value = tslib_1.__classPrivateFieldGet(this, _ServiceDirectoryImpl_directoryCache, "f").get(key);
                if (!value) {
                    throw new Error(`Failed to find directory entry for ${key}`);
                }
            }
            return value;
        });
    }
    getResourceUrl(id) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            (0, utils_1.assertAdspId)(id, 'Provided ID is not for a Resource.', 'resource');
            const serviceUrl = yield this.getServiceUrl((0, utils_1.adspId) `urn:ads:${id.namespace}:${id.service}:${id.api}`);
            // Trim any trailing slash on API url and leading slash on resource
            const resourceUrl = new URL(`${serviceUrl.pathname.replace(/\/$/g, '')}/${id.resource.replace(/^\//, '')}`, serviceUrl);
            return resourceUrl;
        });
    }
}
exports.ServiceDirectoryImpl = ServiceDirectoryImpl;
_ServiceDirectoryImpl_directoryCache = new WeakMap(), _ServiceDirectoryImpl_getOverrideEnv = new WeakMap(), _ServiceDirectoryImpl_tryRetrieveDirectory = new WeakMap();
tslib_1.__decorate([
    (0, utils_1.LimitToOne)((propertyKey, namespace) => `${propertyKey}-${namespace}`),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], ServiceDirectoryImpl.prototype, "retrieveDirectory", null);
//# sourceMappingURL=serviceDirectory.js.map