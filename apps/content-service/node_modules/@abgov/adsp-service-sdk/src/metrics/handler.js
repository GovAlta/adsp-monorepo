"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMetricsHandler = exports.writeMetrics = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const lodash_1 = require("lodash");
const responseTime = require("response-time");
const utils_1 = require("../utils");
const types_1 = require("./types");
const trace_1 = require("../trace");
function writeMetrics(serviceId, directory, logger, tokenProvider, buffer) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a;
        const valueServiceUrl = yield directory.getServiceUrl((0, utils_1.adspId) `urn:ads:platform:value-service:v1`);
        const valueUrl = new URL(`v1/${serviceId.service}/values/service-metrics`, valueServiceUrl);
        // Value service write does not handle writing a batch of values of mixed tenancy, so group by tenant then write.
        for (const tenantId of Object.getOwnPropertyNames(buffer)) {
            try {
                const values = ((_a = buffer[tenantId]) === null || _a === void 0 ? void 0 : _a.splice(0)) || [];
                if (values.length > 0) {
                    const token = yield tokenProvider.getAccessToken();
                    yield axios_1.default.post(valueUrl.href, values, {
                        headers: { Authorization: `Bearer ${token}` },
                        params: { tenantId },
                        timeout: 30000,
                    });
                    logger.debug(`Wrote service metrics to value service.`, {
                        context: 'MetricsHandler',
                        tenant: tenantId,
                    });
                }
            }
            catch (err) {
                logger.warn(`Error encountered writing service metrics. ${err}`, {
                    context: 'MetricsHandler',
                    tenant: tenantId,
                });
            }
        }
    });
}
exports.writeMetrics = writeMetrics;
// Throttle the metric writes so that there isn't a write request per measured request at higher request volumes.
const WRITE_THROTTLE_MS = 60000;
function createMetricsHandler(serviceId, logger, tokenProvider, directory, defaultTenantId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const valuesBuffer = {};
        const writeBuffer = (0, lodash_1.throttle)(writeMetrics, WRITE_THROTTLE_MS, { leading: false });
        const responseTimeHandler = responseTime((req, _res, time) => {
            var _a, _b, _c, _d, _e;
            // Write if there is a tenant context to the request.
            // Check user tenant context if tenant handler is not included on route.
            const tenantId = defaultTenantId || ((_a = req.tenant) === null || _a === void 0 ? void 0 : _a.id) || ((_b = req.user) === null || _b === void 0 ? void 0 : _b.tenantId);
            if (tenantId) {
                const benchmark = req[types_1.REQ_BENCHMARK];
                const metrics = (benchmark === null || benchmark === void 0 ? void 0 : benchmark.metrics) || {};
                const method = req.method;
                const path = `${req.baseUrl || ''}${req.path || ''}` || req.originalUrl;
                const route = (_c = req.route) === null || _c === void 0 ? void 0 : _c.path;
                const ip = req.ip;
                const trace = (0, trace_1.getContextTrace)();
                const value = {
                    timestamp: new Date(),
                    correlationId: trace ? trace.toString() : `${method}:${route || path}`,
                    tenantId: tenantId.toString(),
                    context: {
                        method,
                        path,
                        route,
                        ip,
                        user: (_d = req.user) === null || _d === void 0 ? void 0 : _d.name,
                        userId: (_e = req.user) === null || _e === void 0 ? void 0 : _e.id,
                        trace: trace === null || trace === void 0 ? void 0 : trace.toString(),
                    },
                    value: Object.assign(Object.assign({}, metrics), { responseTime: time }),
                    metrics: Object.assign(Object.assign({}, Object.entries(metrics).reduce((values, [name, value]) => (Object.assign(Object.assign({}, values), { [`total:${name}`]: value, [`${method}:${path}:${name}`]: value })), {})), { [`total:count`]: 1, [`${method}:${path}:count`]: 1, [`total:response-time`]: time, [`${method}:${path}:response-time`]: time }),
                };
                if (!valuesBuffer[value.tenantId]) {
                    valuesBuffer[value.tenantId] = [];
                }
                valuesBuffer[value.tenantId].push(value);
                writeBuffer(serviceId, directory, logger, tokenProvider, valuesBuffer);
            }
        });
        return function (req, res, next) {
            req[types_1.REQ_BENCHMARK] = { timings: {}, metrics: {} };
            responseTimeHandler(req, res, next);
        };
    });
}
exports.createMetricsHandler = createMetricsHandler;
//# sourceMappingURL=handler.js.map