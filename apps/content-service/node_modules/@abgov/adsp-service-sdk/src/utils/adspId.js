"use strict";
var _AdspId_formatSegment;
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertAdspId = exports.adspId = exports.AdspId = exports.AdspIdFormatError = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("./errors");
const HttpStatusCodes = require("http-status-codes");
const PREFIX = 'urn:ads:';
// Note this regex is currently only used for detecting AdspId and not for parsing.
// urn:ads:{namespace}:{service}:{apiVersion}:{resource}
const AdspIdPattern = /^urn:ads(?<namespace>:[a-zA-Z0-9-]{1,50})(?<service>:[a-zA-Z0-9-]{1,50})?(?<api>:[a-zA-Z0-9-]{1,50})?(?<resource>:[a-zA-Z0-9-_/ ]{1,1000})?$/;
class AdspIdFormatError extends errors_1.GoAError {
    constructor(message, extra) {
        super(message, Object.assign({ statusCode: HttpStatusCodes.BAD_REQUEST }, extra));
        Object.setPrototypeOf(this, AdspIdFormatError.prototype);
    }
}
exports.AdspIdFormatError = AdspIdFormatError;
/**
 * AdspId: Utility class for handling ADSP URNs.
 */
class AdspId {
    static isAdspId(urn) {
        return typeof urn === 'string' && AdspIdPattern.test(urn);
    }
    static parse(urn) {
        // urn:ads:{namespace}:{service}:{apiVersion}:{resource}
        if (!(urn === null || urn === void 0 ? void 0 : urn.startsWith(PREFIX))) {
            throw new AdspIdFormatError(`ADSP ID (${urn}) must begin with: ${PREFIX}`);
        }
        const elements = urn.substring(PREFIX.length).split(':');
        const emptyElement = elements.find((e) => !e.trim());
        if (emptyElement) {
            throw new AdspIdFormatError('ADSP ID cannot include empty element.');
        }
        let type;
        if (elements.length === 1) {
            type = 'namespace';
        }
        else if (elements.length === 2) {
            type = 'service';
        }
        else if (elements.length === 3) {
            type = 'api';
        }
        else if (elements.length === 4) {
            type = 'resource';
        }
        else {
            throw new Error(`Value is not a valid ADSP ID: ${urn}`);
        }
        return new AdspId(type, elements[0], elements[1], elements[2], elements[3]);
    }
    constructor(type, namespace, service, api, resource) {
        this.type = type;
        this.namespace = namespace;
        this.service = service;
        this.api = api;
        this.resource = resource;
        _AdspId_formatSegment.set(this, (segment) => {
            return segment ? `:${segment}` : '';
        });
        this.toString = () => `${PREFIX}${this.namespace}` +
            tslib_1.__classPrivateFieldGet(this, _AdspId_formatSegment, "f").call(this, this.service) +
            tslib_1.__classPrivateFieldGet(this, _AdspId_formatSegment, "f").call(this, this.api) +
            tslib_1.__classPrivateFieldGet(this, _AdspId_formatSegment, "f").call(this, this.resource);
    }
}
exports.AdspId = AdspId;
_AdspId_formatSegment = new WeakMap();
/**
 * adspsId: tagged literal function for ADSP URNs
 * @param strings
 * @param parameters
 * @returns Parsed AdspId
 */
function adspId(strings, ...parameters) {
    const combined = strings.reduce((result, string, i) => {
        return result + string + `${parameters[i] || ''}`;
    }, '');
    return AdspId.parse(combined);
}
exports.adspId = adspId;
function assertAdspId(id, errorMessage, ...types) {
    if (!id || !types.includes(id.type)) {
        throw new Error(errorMessage || `ID must for resource type of: ${types.join(', ')}`);
    }
}
exports.assertAdspId = assertAdspId;
//# sourceMappingURL=adspId.js.map