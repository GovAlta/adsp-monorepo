"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializePlatform = void 0;
const tslib_1 = require("tslib");
const access_1 = require("../access");
const configuration_1 = require("../configuration");
const directory_1 = require("../directory");
const event_1 = require("../event");
const healthCheck_1 = require("../healthCheck");
const metrics_1 = require("../metrics");
const registration_1 = require("../registration");
const tenant_1 = require("../tenant");
const trace_1 = require("../trace");
const utils_1 = require("../utils");
function initializePlatform(_a, logOptions, service) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _b;
        var { realm, serviceId, clientSecret, directoryUrl, accessServiceUrl, ignoreServiceAud, configurationConverter, combineConfiguration, enableConfigurationInvalidation, useLongConfigurationCacheTTL, additionalExtractors } = _a, registration = tslib_1.__rest(_a, ["realm", "serviceId", "clientSecret", "directoryUrl", "accessServiceUrl", "ignoreServiceAud", "configurationConverter", "combineConfiguration", "enableConfigurationInvalidation", "useLongConfigurationCacheTTL", "additionalExtractors"]);
        (0, utils_1.assertAdspId)(serviceId, null, 'service');
        const logger = ('debug' in logOptions ? logOptions : logOptions === null || logOptions === void 0 ? void 0 : logOptions.logger) ||
            (0, utils_1.createLogger)(serviceId.toString(), logOptions === null || logOptions === void 0 ? void 0 : logOptions.logLevel);
        const tokenProvider = (0, access_1.createTokenProvider)({ logger, serviceId, clientSecret, accessServiceUrl, realm });
        const directory = (service === null || service === void 0 ? void 0 : service.directory) || (0, directory_1.createDirectory)({ logger, directoryUrl });
        // Initialization is not dependent on registration, so registration completes asynchronously.
        const registrar = (0, registration_1.createServiceRegistrar)({ logger, directory, tokenProvider });
        registrar
            .register(Object.assign(Object.assign({}, registration), { serviceId }))
            .catch((err) => logger.warn(`Error encountered during service registration. ${err}`));
        const tenantService = (service === null || service === void 0 ? void 0 : service.tenantService) || (0, tenant_1.createTenantService)({ logger, directory, tokenProvider });
        const tenantHandler = (0, tenant_1.createTenantHandler)(tenantService);
        const coreStrategy = yield (0, access_1.createRealmStrategy)({
            realm: 'core',
            logger,
            serviceId,
            accessServiceUrl,
            tenantService,
            ignoreServiceAud,
            additionalExtractors,
        });
        const tenantStrategy = realm === 'core'
            ? (0, access_1.createTenantStrategy)({
                logger,
                serviceId,
                accessServiceUrl,
                tenantService,
                ignoreServiceAud,
                additionalExtractors,
            })
            : yield (0, access_1.createRealmStrategy)({
                realm,
                logger,
                serviceId,
                accessServiceUrl,
                tenantService,
                ignoreServiceAud,
                additionalExtractors,
            });
        let configurationService = service === null || service === void 0 ? void 0 : service.configurationService;
        let clearCached = function (_tenantId, _serviceId) {
            // no-op implementation for when configuration is externally provided.
        };
        if (!configurationService) {
            const configServiceImpl = (0, configuration_1.createConfigurationService)({
                serviceId,
                logger,
                directory,
                tokenProvider,
                useNamespace: ((_b = registration.configuration) === null || _b === void 0 ? void 0 : _b.useNamespace) || false,
                converter: configurationConverter,
                combine: combineConfiguration,
                enableConfigurationInvalidation,
                useLongConfigurationCacheTTL,
            });
            configurationService = configServiceImpl;
            clearCached = function (tenantId, serviceId) {
                configServiceImpl.clearCached(tenantId, serviceId.namespace, serviceId.service);
            };
        }
        const configurationHandler = (0, configuration_1.createConfigurationHandler)(tokenProvider, configurationService, serviceId);
        const eventService = (service === null || service === void 0 ? void 0 : service.eventService) ||
            (0, event_1.createEventService)({
                isCore: realm === 'core',
                logger,
                serviceId,
                directory,
                tokenProvider,
                events: registration.events,
            });
        // Skip health checks on anything that's injected or anything not configured (assumed not used).
        const healthCheck = (0, healthCheck_1.createHealthCheck)(logger, accessServiceUrl, directoryUrl, directory, {
            directory: !!(service === null || service === void 0 ? void 0 : service.directory),
            tenant: !!(service === null || service === void 0 ? void 0 : service.tenantService),
            configuration: !!(service === null || service === void 0 ? void 0 : service.configurationService) || !registration.configurationSchema,
            event: !!(service === null || service === void 0 ? void 0 : service.eventService) || !registration.events || !registration.events.length,
        });
        const metricsHandler = yield (0, metrics_1.createMetricsHandler)(serviceId, logger, tokenProvider, directory);
        // Note: Sample rate is not currently used in the SDK.
        const traceHandler = (0, trace_1.createTraceHandler)({ logger, sampleRate: 0 });
        return {
            tokenProvider,
            coreStrategy,
            tenantService,
            tenantStrategy,
            tenantHandler,
            configurationService,
            configurationHandler,
            eventService,
            directory,
            healthCheck,
            clearCached,
            metricsHandler,
            traceHandler,
            logger,
        };
    });
}
exports.initializePlatform = initializePlatform;
//# sourceMappingURL=platform.js.map