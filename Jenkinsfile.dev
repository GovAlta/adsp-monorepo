// This Jenskins file is used for builds of branches.
// The pipeline does not use SCM and this file maintained here for reference only.
def baseCommand = "--base=origin/master --head=HEAD"
def affectedApps = []
def push_sha

pipeline {
  options {
    buildDiscarder(logRotator(numToKeepStr: '5', artifactNumToKeepStr: '5'))
  }
  agent {
    node {
      label "node12-cypress"
    }
  }
  parameters {
    string(
      name: 'source_repo',
      defaultValue: 'https://gitlab.gov.ab.ca/dio/core/core-services.git',
      description: 'Repo url.'
    )
    string(
      name: 'source_ref',
      defaultValue: 'refs/heads/master',
      description: 'Ref to build.'
    )
    booleanParam(
      name: 'deploy_branch',
      defaultValue: false,
      description: 'Flag indicating if the branch deployment should be created.'
    )
    booleanParam(
      name: 'run_cypress',
      defaultValue: false,
      description: 'Flag indicating if the cypress e2e tests should be run.'
    )
  }
  triggers {
    GenericTrigger(
     genericVariables: [
      [key: 'source_ref', value: '$.ref'],
      [key: 'push_sha', value: '$.checkout_sha', defaultValue: ' ']
     ],
     causeString: 'Building pushed changes ($push_sha) on $source_ref ...',
     tokenCredentialId: 'gitlab-webhook-token',

     printContributedVariables: false,
     printPostContent: false,
     silentResponse: false,

     regexpFilterText: '$source_ref:$push_sha',
     regexpFilterExpression: '^(?!refs/heads/master).*:[^\\s]'
    )
  }
  stages {
    stage("Prepare") {
      steps {
        checkout(
          [
            $class: 'GitSCM',
            branches: [[
              name: push_sha ?: source_ref
            ]],
            doGenerateSubmoduleConfigurations: false,
            extensions: [],
            submoduleCfg: [],
            userRemoteConfigs: [[
              credentialsId: 'core-services-infra-core-services-gitlab',
              url: "${source_repo}"
            ]]
          ]
        )

        sh "npm install"
      }
    }
    stage("Lint"){
      steps {
        sh "npx nx affected --target=lint ${baseCommand} --parallel"
      }
    }
    stage("Test"){
      steps {
        sh "npx nx affected --target=test ${baseCommand} --parallel"
      }
    }
    stage("Build") {
      steps {
        sh "npx nx affected --target=build --configuration=production ${baseCommand} --parallel"
      }
    }
    stage("Cypress Test"){
      when {
        expression { return params.run_cypress }
      }
      steps {
        sh "npm ci"
        sh "npx nx e2e tenant-management-webapp-e2e --dev-server-target='' --headless=true --env.'TAGS'='@smoke-test or @dev-build' --baseUrl 'https://tenant-management-webapp-core-services-dev.os99.gov.ab.ca/'"
      }
      post {
        always {
          junit "**/results/*.xml"
          cucumber "**/cucumber-json/*.json"
          sh "node ./apps/tenant-management-webapp-e2e/src/support/multiple-cucumber-html-reporter.js"
          zip zipFile: 'cypress-smoke-test-html-report.zip', archive: false, dir: 'dist/cypress'
          archiveArtifacts artifacts: 'cypress-smoke-test-html-report.zip'
        }
      }
    }
    stage("Deploy Branch") {
      when {
        expression {
          return params.deploy_branch
        }
      }
      steps {
        script {
          affectedApps = sh (
            script: "npx nx affected:apps --plain ${baseCommand}",
            returnStdout: true
          ).tokenize()

          def deployBranch = params.source_ref.split('/').last()

          openshift.withCluster() {
            openshift.withProject('core-services-dev') {
              affectedApps.each { deployApp ->

                // Check for managed deployment file.
                def managedDeployFile = ".openshift/managed/${deployApp}.yml"
                if (fileExists(file: managedDeployFile)) {
                  echo "Applying managed deployment: ${deployApp} ..."

                  // Filtering by label is handled in groovy because the label selector on
                  // openshift.apply does not appear to work properly with a list.
                  def deployment = openshift.process(
                    readYaml(file: managedDeployFile),
                    "-p",
                    "NAME_SUFFIX=-${deployBranch}",
                    "BUILD_TAG=b-${deployBranch}",
                    "DEPLOY_TAG=b-${deployBranch}",
                    "ROUTE_HOST=${deployApp}-${deployBranch}.os99.gov.ab.ca"
                  )
                  .findAll{ it.metadata.labels["apply-branch"] == 'true' }

                  def deployed = openshift.apply(deployment)

                  def bc = deployed.narrow('bc')
                  if ( bc.exists() ) {
                    if(deployApp.endsWith("app")){
                      bc.startBuild("--from-dir=dist/apps/${deployApp}", "--wait", "--follow")
                    } else {
                      bc.startBuild("--from-dir=.", "--wait", "--follow")
                    }
                  }

                  def dc = deployed.narrow('dc')
                  if ( dc.exists() ) {
                    def rm = dc.rollout()
                    rm.latest()
                    rm.status()
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  post {
    failure {
      slackSend color: "bad", message: "Core Services branch ${source_ref} build ${env.BUILD_NUMBER} Failed: ${env.BUILD_URL}"
    }
  }
}
